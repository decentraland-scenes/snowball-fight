/// <reference types="dcl" />
/// <reference types="env" />

/**
 * @public
 */
export declare class ActionsSequenceSystem implements ISystem {
    private beginSequenceNode;
    private currentSequenceNode;
    private running;
    private started;
    private onFinishCallback?;
    constructor(sequenceBuilt?: ActionsSequenceSystem.SequenceBuilder);
    startSequence(sequenceBuilt: ActionsSequenceSystem.SequenceBuilder): void;
    setOnFinishCallback(onFinishCallback: () => void): void;
    isRunning(): boolean;
    stop(): void;
    resume(): void;
    reset(): void;
    getRunningAction(): ActionsSequenceSystem.IAction | null;
    update(dt: number): void;
}

/**
 * @public
 */
export declare namespace ActionsSequenceSystem {
    export interface IAction {
        onStart(): void;
        update(dt: number): void;
        onFinish(): void;
        hasFinished: boolean;
    }
    export class SequenceBuilder {
        private currentSequenceNode;
        beginSequenceNode: SequenceNode | null;
        private whileNodeStack;
        then(action: ActionsSequenceSystem.IAction): SequenceBuilder;
        if(condition: () => boolean): SequenceBuilder;
        else(): SequenceBuilder;
        endIf(): SequenceBuilder;
        while(condition: () => boolean): SequenceBuilder;
        endWhile(): SequenceBuilder;
        breakWhile(): SequenceBuilder;
    }
}

/**
 * Maps a value from one range of values to its equivalent, scaled in proportion to another range of values, using maximum and minimum.
 *
 * @param text - Text to use on label
 * @param parent - Entity to place label on.
 * @param billboard - If true, label turns to always face player.
 * @param color - Text color. Black by default.
 * @param size - Text font size, 3 by default.
 * @param textOffset - Offset from parent entity's position. By default 1.5 meters above the parent.
 * @returns A new entity with the configured settings that is a child of the provided parent
 * @public
 */
export declare function addLabel(text: string, parent: IEntity, billboard?: boolean, color?: Color3, size?: number, textOffset?: TranformConstructorArgs): Entity;

/**
 * Quick function to add a trigger area that is removed after being triggered once.
 * @public
 *
 * @param shape - shape of the triggering collider area
 * @param data - An object with additional parameters for the trigger component
 * @param parent - Optional entity to set as a parent to the trigger area entity.
 */
export declare function addOneTimeTrigger(shape: TriggerBoxShape | TriggerSphereShape, data?: TriggerData, parent?: Entity): Entity;

/**
 * Quick function to add a cube that can run functions when clicked. By default only displayed when in preview mode for tests.
 *
 * @param pos - Transform arguments for the cube, including position, scale and rotation
 * @param triggeredFunction - Function to execute every time the cube is clicked.
 * @param label - Text to display over cube and on hover.
 * @param color - Cube color.
 * @param sphere - If true, use a sphere shape instead of cube.
 * @param noCollider - If true, cube has no collider.
 * @returns A new entity with the configured settings and a label as a child
 * @public
 */
export declare function addTestCube(pos: TranformConstructorArgs, triggeredFunction: () => void, label?: string, color?: Color3, sphere?: boolean, noCollider?: boolean, keepInProduction?: boolean): Promise<Entity>;

/**
 * Clamps a value so that it doesn't exceed a minimum or a maximum value.
 *
 * @param value - input number
 * @param min - Minimum output value.
 * @param max - Maximum output value.
 * @returns The resulting mapped value between the min and max
 * @public
 */
export declare function clamp(value: number, min: number, max: number): number;

/**
 * Execute once after X milliseconds
 * @public
 */
export declare class Delay implements ITimerComponent {
    elapsedTime: number;
    targetTime: number;
    onTargetTimeReached: (ownerEntity: IEntity) => void;
    private onTimeReachedCallback?;
    /**
     * @param millisecs - amount of time in milliseconds
     * @param onTimeReachedCallback - callback for when time is reached
     */
    constructor(millisecs: number, onTimeReachedCallback?: () => void);
    setCallback(onTimeReachedCallback: () => void): void;
}

/**
 * Remove entity after X milliseconds
 * @public
 */
export declare class ExpireIn implements ITimerComponent {
    elapsedTime: number;
    targetTime: number;
    onTargetTimeReached: (ownerEntity: IEntity) => void;
    private onTimeReachedCallback?;
    /**
     * @param millisecs - amount of time in milliseconds
     * @param onTimeReachedCallback - callback for when time is reached
     */
    constructor(millisecs: number, onTimeReachedCallback?: () => void);
    setCallback(onTimeReachedCallback: () => void): void;
}

/**
 * Component to move a entity down a fixed path in an amount of time
 * @public
 */
export declare class FollowCurvedPathComponent implements ITransformComponent {
    private points;
    private speed;
    private normalizedTime;
    private currentIndex;
    private turnToFaceNext;
    private facingNext;
    onFinishCallback?: () => void;
    /**
     * Create a FollowCurvedPathComponent instance to add as a component to a Entity
     * @param points - array of points that the curve must pass through
     * @param duration - duration of the movement through the path
     * @param numberOfSegments - how many straight line segments to use to construct the curve
     * @param turnToFaceNext - if true, rotates for each segment to always look forward
     * @param closedCircle - if true, traces a circle that starts back at the beginning, keeping the curvature rounded in the seams too
     * @param onFinishCallback - called when movement ends
     */
    constructor(points: Vector3[], duration: number, numberOfSegments: number, turnToFaceNext?: boolean, closedCircle?: boolean, onFinishCallback?: () => void);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Component to move an entity down a fixed path in a given amount of time
 * @public
 */
export declare class FollowPathComponent implements ITransformComponent {
    private points;
    private speed;
    private normalizedTime;
    private currentIndex;
    onFinishCallback?: () => void;
    onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void;
    /**
     * Create a FollowPathComponent instance to add as a component to a Entity
     * @param points - array of points for the path
     * @param duration - duration of the movement through the path
     * @param onFinishCallback - called when movement ends
     * @param onPointReachedCallback - called everytime an entity reaches a point of the path
     */
    constructor(points: Vector3[], duration: number, onFinishCallback?: () => void, onPointReachedCallback?: (currentPoint: Vector3, nextPoint: Vector3) => void);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Returns the position of an entity that is a child of other entities, relative to the scene instead of relative to the parent. Returns a Vector3.
 *
 * @param entity - Entity to calculate position
 * @returns The Entity's global position in reference to the scene's origin
 * @public
 */
export declare function getEntityWorldPosition(entity: IEntity): Vector3;

/**
 * Returns the position of an entity that is a child of other entities, relative to the scene instead of relative to the parent. Returns a Vector3.
 *
 * @param entity - Entity to calculate position
 * @returns The Entity's global rotation in reference to the scene's origin
 * @public
 */
export declare function getEntityWorldRotation(entity: IEntity): Quaternion;

/**
 * @public
 */
export declare function Interpolate(type: InterpolationType, t: number): number;

/**
 * @public
 */
export declare enum InterpolationType {
    LINEAR = 0,
    EASEINQUAD = 1,
    EASEOUTQUAD = 2,
    EASEQUAD = 3,
    EASEINSINE = "easeinsine",
    EASEOUTSINE = "easeoutsine",
    EASESINE = "easeinoutsine",
    EASEINEXPO = "easeinexpo",
    EASEOUTEXPO = "easeoutexpo",
    EASEEXPO = "easeinoutexpo",
    EASEINELASTIC = "easeinelastic",
    EASEOUTELASTIC = "easeoutelastic",
    EASEELASTIC = "easeinoutelastic",
    EASEINBOUNCE = "easeinbounce",
    EASEOUTEBOUNCE = "easeoutbounce",
    EASEBOUNCE = "easeinoutbounce"
}

/**
 * Execute every X milliseconds
 * @public
 */
export declare class Interval implements ITimerComponent {
    elapsedTime: number;
    targetTime: number;
    onTargetTimeReached: (ownerEntity: IEntity) => void;
    private onTimeReachedCallback?;
    /**
     * @param millisecs - amount of time in milliseconds
     * @param onTimeReachedCallback - callback for when time is reached
     */
    constructor(millisecs: number, onTimeReachedCallback?: () => void);
    setCallback(onTimeReachedCallback: () => void): void;
}

/**
 * @public
 */
export declare interface ITimerComponent {
    elapsedTime: number;
    targetTime: number;
    onTargetTimeReached: (ownerEntity: IEntity) => void;
}

/**
 * @public
 */
export declare interface ITransformComponent {
    onFinishCallback?: () => void;
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Component to rotate entity indefinitely until stop is called
 * @public
 */
export declare class KeepRotatingComponent implements ITransformComponent {
    onFinishCallback?: () => void;
    private rotationVelocity;
    private rotation;
    private finished;
    /**
     * Rotates an entity continuously. The entity will keep rotating forever until it's explicitly stopped or the component is removed.
     * @param rotationVelocity - a quaternion describing the desired rotation to perform each second second
     * @param onFinishCallback - called when rotation ends
     */
    constructor(rotationVelocity: Quaternion, onFinishCallback?: () => void);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
    stop(): void;
}

/**
 * Maps a value from one range of values to its equivalent, scaled in proportion to another range of values, using maximum and minimum.
 *
 * @param value - value input number
 * @param min1 - min1 Minimum value in the range of the input.
 * @param max1 - max1 Maximum value in the range of the input.
 * @param min2 - min2 Minimum value in the range of the output.
 * @param max2 - max2 Maximum value in the range of the output.
 * @returns The resulting mapped value between the new min and max
 * @public
 */
export declare function map(value: number, min1: number, max1: number, min2: number, max2: number): number;

/**
 * Component to translate entity from one position (start) to another (end) in an amount of time
 * @public
 */
export declare class MoveTransformComponent implements ITransformComponent {
    private start;
    private end;
    private speed;
    private normalizedTime;
    private interpolationType;
    private lerpTime;
    onFinishCallback?: () => void;
    /**
     * Create a MoveTransformComponent instance to add as a component to a Entity
     * @param start - starting position
     * @param end - ending position
     * @param duration - duration (in seconds) of start to end translation
     * @param onFinishCallback - called when translation ends
     * @param interpolationType - type of interpolation to be used (default: LINEAR)
     */
    constructor(start: ReadOnlyVector3, end: ReadOnlyVector3, duration: number, onFinishCallback?: () => void, interpolationType?: InterpolationType);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Component to rotate entity from one rotation (start) to another (end) in an amount of time
 * @public
 */
export declare class RotateTransformComponent implements ITransformComponent {
    private start;
    private end;
    private speed;
    private normalizedTime;
    private interpolationType;
    private lerpTime;
    onFinishCallback?: () => void;
    /**
     * Create a RotateTransformComponent instance to add as a component to a Entity
     * @param start - starting rotation
     * @param end - ending rotation
     * @param duration - duration (in seconds) of start to end rotation
     * @param onFinishCallback - called when rotation ends
     * @param interpolationType - type of interpolation to be used (default: LINEAR)
     */
    constructor(start: ReadOnlyQuaternion, end: ReadOnlyQuaternion, duration: number, onFinishCallback?: () => void, interpolationType?: InterpolationType);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Component to scale entity from one value (start) to another (end) in an amount of time
 * @public
 */
export declare class ScaleTransformComponent implements ITransformComponent {
    private start;
    private end;
    private speed;
    private normalizedTime;
    private interpolationType;
    private lerpTime;
    onFinishCallback?: () => void;
    /**
     * Create a ScaleTransformComponent instance to add as a component to a Entity
     * @param start - starting scale
     * @param end - ending scale
     * @param duration - duration (in seconds) of start to end scaling
     * @param onFinishCallback - called when scaling ends
     * @param interpolationType - type of interpolation to be used (default: LINEAR)
     */
    constructor(start: ReadOnlyVector3, end: ReadOnlyVector3, duration: number, onFinishCallback?: () => void, interpolationType?: InterpolationType);
    update(dt: number): void;
    hasFinished(): boolean;
    assignValueToTransform(transform: Transform): void;
}

/**
 * Quick function to send HTTP requests to an external address
 *
 * @param url - URL to send request to
 * @param method - HTTP method (GET by default)
 * @param headers - Headers to add to request, as a JSON with key/value pairs per each header
 * @param body - Body to add to request, as a JSON object
 * @returns The response of the request. If the response is a JSON object, it will be parsed.
 * @public
 */
export declare function sendRequest(url: string, method?: string, headers?: any, body?: any): Promise<any>;

/**
 * @public
 */
export declare class SequenceNode {
    action: ActionsSequenceSystem.IAction | null;
    next: SequenceNode | null;
    then(next: SequenceNode): SequenceNode;
    onStart(): void;
    update(dt: number): void;
    onFinish(): void;
    hasFinish(): boolean;
    getSequence(): SequenceNode;
}

/**
 * Quick function to delay the execution of a lambda after a given amount of time.
 * @public
 *
 * @param ms - Time im milliseconds to delay the function
 * @param callback - Function to execute when the time is up
 */
export declare function setTimeout(ms: number, callback: () => void): Entity;

/**
 * Toggle component for entities with two states (ON or OFF)
 * @public
 */
export declare class ToggleComponent {
    enabled: boolean;
    private onValueChangedCallback?;
    private state;
    /**
     * Create an instance of a ToggleComponent
     * @param startingState - starting state of the toggle (ON or OFF)
     * @param onValueChangedCallback - called when toggle state changed
     */
    constructor(startingState?: ToggleState, onValueChangedCallback?: (value: ToggleState) => void);
    /**
     * Set trigger to a state
     * @param state - new state
     */
    set(state: ToggleState): void;
    /**
     * Toggle state of ToggleComponent
     */
    toggle(): void;
    /**
     * Get if the current toggle state is ON
     * @returns
     */
    isOn(): boolean;
    /**
     * Set callback for when ToggleComponent state changed
     * @param onValueChangedCallback - callback
     */
    setCallback(onValueChangedCallback: (value: ToggleState) => void): void;
}

/**
 * @public
 */
export declare enum ToggleState {
    Off = 0,
    On = 1
}

/**
 * @public
 */
export declare class TransformSystem implements ISystem {
    static _instance: TransformSystem | null;
    private _components;
    private _componentGroups;
    static createAndAddToEngine(): TransformSystem;
    static registerCustomComponent<T extends ITransformComponent>(component: ComponentConstructor<T>): void;
    addComponentType(component: ComponentConstructor<ITransformComponent>): void;
    private constructor();
    update(dt: number): void;
    private updateComponent;
}

/**
 * Define a box-shaped area for using on a TriggerComponent
 * @param size - The scale of the box area. By default 2x2x2
 * @param position - The offset from the position of the entity that owns the TriggerComponent
 * @public
 */
export declare class TriggerBoxShape {
    size: Vector3;
    position: Vector3;
    constructor(size?: Vector3, position?: Vector3);
}

/**
 * @public
 */
export declare class TriggerComponent {
    /**
     * Is the trigger enabled? If false, the associated functions aren't triggered.
     */
    enabled: boolean;
    /**
     * shape of the collider
     */
    shape: TriggerBoxShape | TriggerSphereShape;
    /**
     * bit layer of the Tigger (usefull to discriminate between trigger events)
     */
    layer: number;
    /**
     * against which layer are we going to check trigger's collisions
     */
    triggeredByLayer: number;
    /**
     * callback when trigger is entered
     */
    onTriggerEnter?: (entity: Entity) => void;
    /**
     * callback when trigger is exit
     */
    onTriggerExit?: (entity: Entity) => void;
    /**
     * callback when trigger is entered
     */
    onCameraEnter?: () => void;
    /**
     * callback when trigger is exit
     */
    onCameraExit?: () => void;
    /**
     * get if debug is enabled
     */
    get debugEnabled(): boolean;
    private _debugEnabled;
    /**
     * @param shape - shape of the triggering collider area
     * @param data - An object with additional parameters for the trigger component
     */
    constructor(shape: TriggerBoxShape | TriggerSphereShape, data?: TriggerData);
}

/**
 * Object with data for a NPCTriggerComponent
 * @public
 */
export declare type TriggerData = {
    /**
     * layer of the Trigger, useful to discriminate between trigger events. You can set multiple layers by using a | symbol.
     */
    layer?: number;
    /**
     * against which layers to check collisions
     */
    triggeredByLayer?: number;
    /**
     * callback when an entity of a valid layer enters the trigger area
     */
    onTriggerEnter?: (entity: Entity) => void;
    /**
     * callback when an entity of a valid layer leaves the trigger area
     */
    onTriggerExit?: (entity: Entity) => void;
    /**
     * callback when the player enters the trigger area
     */
    onCameraEnter?: () => void;
    /**
     * callback when the player leaves the trigger area
     */
    onCameraExit?: () => void;
    /**
     * when true makes the trigger area visible for debug purposes.
     */
    enableDebug?: boolean;
};

/**
 * Define a sphere-shaped area for using on a TriggerComponent
 * @param radius - The radius of the sphere area. By default 2
 * @param position - The offset from the position of the entity that owns the TriggerComponent
 * @public
 */
export declare class TriggerSphereShape {
    radius: number;
    position: Vector3;
    constructor(radius?: number, position?: Vector3);
}

/**
 * @public
 */
export declare class TriggerSystem implements ISystem {
    private static _instance;
    static get instance(): TriggerSystem;
    private _triggers;
    private _cameraTriggerWrapper;
    private _componentGroup;
    private constructor();
    static createAndAddToEngine(): TriggerSystem;
    /**
     * set a custom trigger's shape for the camera
     * @param shape - custom trigger's shape
     */
    setCameraTriggerShape(shape: TriggerBoxShape | TriggerSphereShape): void;
    update(): void;
    private shouldWrapTriggerEntity;
    private wrapTriggerEntity;
    private static removeTriggerFromSystem;
    private static disengageCollision;
    private static engageCollision;
    private checkCollisionAgainstCamera;
    private checkCollisionAgainstOtherTriggers;
    private static canTriggersCollide;
    private static areColliding;
    private static areCollidingAABB;
    private static areCollidingSphere;
    private static areCollidingAABBSphere;
    private static getBoxShapeValues;
}

export { }
