{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/codegen/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport * as path from \"path\";\nimport { readFileSync } from \"fs\";\nimport { IStructure, Class, Interface, Property, Context } from \"./types\";\n\nlet currentStructure: IStructure;\nlet currentProperty: Property;\n\nlet globalContext: Context;\n\nfunction defineProperty(property: Property, initializer: any) {\n    if (ts.isIdentifier(initializer)) {\n        property.type = \"ref\";\n        property.childType = initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n        property.type = initializer.properties[0].name.text;\n        property.childType = initializer.properties[0].initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n        property.type = \"array\";\n        property.childType = initializer.elements[0].text;\n\n    } else {\n        property.type = initializer.text;\n    }\n}\n\nfunction inspectNode(node: ts.Node, context: Context, decoratorName: string) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ImportClause:\n            const specifier = (node.parent as any).moduleSpecifier;\n            if (specifier && (specifier.text as string).startsWith('.'))  {\n                const currentDir = path.dirname(node.getSourceFile().fileName);\n                const pathToImport = path.resolve(currentDir, specifier.text);\n                parseFiles([pathToImport], decoratorName, globalContext);\n            }\n            break;\n\n        case ts.SyntaxKind.ClassDeclaration:\n            currentStructure = new Class();\n\n            const heritageClauses = (node as ts.ClassLikeDeclarationBase).heritageClauses;\n            if (heritageClauses && heritageClauses.length > 0) {\n                (currentStructure as Class).extends = heritageClauses[0].types[0].expression.getText();\n            }\n\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n            //\n            // Only generate Interfaces if it has \"Message\" on its name.\n            // Example: MyMessage\n            //\n            const interfaceName = (node as ts.TypeParameterDeclaration).name.escapedText.toString();\n            if (interfaceName.indexOf(\"Message\") !== -1) {\n                currentStructure = new Interface();\n                currentStructure.name = interfaceName;\n\n                context.addStructure(currentStructure);\n            }\n            break;\n\n        case ts.SyntaxKind.ExtendsKeyword:\n            // console.log(node.getText());\n            break;\n\n        case ts.SyntaxKind.PropertySignature:\n            if (currentStructure instanceof Interface) {\n                const interfaceDeclaration = node.parent;\n\n                if (\n                    currentStructure.name !== (interfaceDeclaration as ts.TypeParameterDeclaration).name.escapedText.toString()\n                ) {\n                    // skip if property if for a another interface than the one we're interested in.\n                    break;\n                }\n\n                // define a property of an interface\n                const property = new Property();\n                property.name = (node as any).name.escapedText.toString();\n                property.type = (node as any).type.getText();\n                currentStructure.addProperty(property);\n            }\n            break;\n\n        case ts.SyntaxKind.Identifier:\n            if (\n                node.getText() === \"deprecated\" &&\n                node.parent.kind !== ts.SyntaxKind.ImportSpecifier\n            ) {\n                currentProperty = new Property();\n                currentProperty.deprecated = true;\n                break;\n            }\n\n            if (node.getText() === decoratorName) {\n                const prop: any = node.parent?.parent?.parent;\n                const propDecorator = prop?.decorators;\n                const hasExpression = prop?.expression?.arguments;\n\n                /**\n                 * neither a `@type()` decorator or `type()` call. skip.\n                 */\n                if (!propDecorator && !hasExpression) {\n                    break;\n                }\n\n                // using as decorator\n                if (propDecorator) {\n                    /**\n                     * Calling `@type()` as decorator\n                     */\n                    const typeDecorator: any = propDecorator.find((decorator => {\n                        return (decorator.expression as any).expression.escapedText === decoratorName;\n                    })).expression;\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = typeDecorator.arguments[0];\n                    defineProperty(property, typeArgument);\n\n                } else if (\n                    prop.expression.arguments?.[1] &&\n                    prop.expression.expression.arguments?.[0]\n                ) {\n                    /**\n                     * Calling `type()` as a regular method\n                     */\n                    const property = currentProperty || new Property();\n                    property.name = prop.expression.arguments[1].text;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = prop.expression.expression.arguments[0];\n                    defineProperty(property, typeArgument);\n                }\n\n\n            } else if (\n                node.getText() === \"defineTypes\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * JavaScript source file (`.js`)\n                 * Using `defineTypes()`\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const className = callExpression.arguments[0].getText()\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i=0; i<types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    defineProperty(property, prop.initializer);\n                }\n\n            }\n\n            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {\n                currentStructure.name = node.getText();\n            }\n\n            currentProperty = undefined;\n\n            break;\n    }\n\n    ts.forEachChild(node, (n) => inspectNode(n, context, decoratorName));\n}\n\nlet parsedFiles: { [filename: string]: boolean };\n\nexport function parseFiles(\n    fileNames: string[],\n    decoratorName: string = \"type\",\n    context: Context = new Context()\n) {\n    /**\n     * Re-set globalContext for each test case\n     */\n    if (globalContext !== context) {\n        parsedFiles = {};\n        globalContext = context;\n    }\n\n    fileNames.forEach((fileName) => {\n        let sourceFile: ts.Node;\n        let sourceFileName: string;\n\n        const fileNameAlternatives = [];\n\n        if (\n            !fileName.endsWith(\".ts\") &&\n            !fileName.endsWith(\".js\") &&\n            !fileName.endsWith(\".mjs\")\n        ) {\n            fileNameAlternatives.push(`${fileName}.ts`);\n            fileNameAlternatives.push(`${fileName}/index.ts`);\n\n        } else {\n            fileNameAlternatives.push(fileName);\n        }\n\n        for (let i = 0; i < fileNameAlternatives.length; i++) {\n            try {\n                sourceFileName = path.resolve(fileNameAlternatives[i]);\n\n                if (parsedFiles[sourceFileName]) {\n                    break;\n                }\n\n                sourceFile = ts.createSourceFile(\n                    sourceFileName,\n                    readFileSync(sourceFileName).toString(),\n                    ts.ScriptTarget.Latest,\n                    true\n                );\n\n                parsedFiles[sourceFileName] = true;\n\n                break;\n            } catch (e) {\n                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);\n            }\n        }\n\n        if (sourceFile) {\n            inspectNode(sourceFile, context, decoratorName);\n        }\n    });\n\n    return context.getStructures();\n}"]}