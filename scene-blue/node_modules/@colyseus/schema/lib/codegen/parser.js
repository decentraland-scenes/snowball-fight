"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = void 0;
var ts = require("typescript");
var path = require("path");
var fs_1 = require("fs");
var types_1 = require("./types");
var currentStructure;
var currentProperty;
var globalContext;
function defineProperty(property, initializer) {
    if (ts.isIdentifier(initializer)) {
        property.type = "ref";
        property.childType = initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {
        property.type = initializer.properties[0].name.text;
        property.childType = initializer.properties[0].initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {
        property.type = "array";
        property.childType = initializer.elements[0].text;
    }
    else {
        property.type = initializer.text;
    }
}
function inspectNode(node, context, decoratorName) {
    var _a, _b, _c, _d, _e;
    switch (node.kind) {
        case ts.SyntaxKind.ImportClause:
            var specifier = node.parent.moduleSpecifier;
            if (specifier && specifier.text.startsWith('.')) {
                var currentDir = path.dirname(node.getSourceFile().fileName);
                var pathToImport = path.resolve(currentDir, specifier.text);
                parseFiles([pathToImport], decoratorName, globalContext);
            }
            break;
        case ts.SyntaxKind.ClassDeclaration:
            currentStructure = new types_1.Class();
            var heritageClauses = node.heritageClauses;
            if (heritageClauses && heritageClauses.length > 0) {
                currentStructure.extends = heritageClauses[0].types[0].expression.getText();
            }
            context.addStructure(currentStructure);
            break;
        case ts.SyntaxKind.InterfaceDeclaration:
            //
            // Only generate Interfaces if it has "Message" on its name.
            // Example: MyMessage
            //
            var interfaceName = node.name.escapedText.toString();
            if (interfaceName.indexOf("Message") !== -1) {
                currentStructure = new types_1.Interface();
                currentStructure.name = interfaceName;
                context.addStructure(currentStructure);
            }
            break;
        case ts.SyntaxKind.ExtendsKeyword:
            // console.log(node.getText());
            break;
        case ts.SyntaxKind.PropertySignature:
            if (currentStructure instanceof types_1.Interface) {
                var interfaceDeclaration = node.parent;
                if (currentStructure.name !== interfaceDeclaration.name.escapedText.toString()) {
                    // skip if property if for a another interface than the one we're interested in.
                    break;
                }
                // define a property of an interface
                var property = new types_1.Property();
                property.name = node.name.escapedText.toString();
                property.type = node.type.getText();
                currentStructure.addProperty(property);
            }
            break;
        case ts.SyntaxKind.Identifier:
            if (node.getText() === "deprecated" &&
                node.parent.kind !== ts.SyntaxKind.ImportSpecifier) {
                currentProperty = new types_1.Property();
                currentProperty.deprecated = true;
                break;
            }
            if (node.getText() === decoratorName) {
                var prop = (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent;
                var propDecorator = prop === null || prop === void 0 ? void 0 : prop.decorators;
                var hasExpression = (_c = prop === null || prop === void 0 ? void 0 : prop.expression) === null || _c === void 0 ? void 0 : _c.arguments;
                /**
                 * neither a `@type()` decorator or `type()` call. skip.
                 */
                if (!propDecorator && !hasExpression) {
                    break;
                }
                // using as decorator
                if (propDecorator) {
                    /**
                     * Calling `@type()` as decorator
                     */
                    var typeDecorator = propDecorator.find((function (decorator) {
                        return decorator.expression.expression.escapedText === decoratorName;
                    })).expression;
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    var typeArgument = typeDecorator.arguments[0];
                    defineProperty(property, typeArgument);
                }
                else if (((_d = prop.expression.arguments) === null || _d === void 0 ? void 0 : _d[1]) &&
                    ((_e = prop.expression.expression.arguments) === null || _e === void 0 ? void 0 : _e[0])) {
                    /**
                     * Calling `type()` as a regular method
                     */
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.expression.arguments[1].text;
                    currentStructure.addProperty(property);
                    var typeArgument = prop.expression.expression.arguments[0];
                    defineProperty(property, typeArgument);
                }
            }
            else if (node.getText() === "defineTypes" &&
                (node.parent.kind === ts.SyntaxKind.CallExpression ||
                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)) {
                /**
                 * JavaScript source file (`.js`)
                 * Using `defineTypes()`
                 */
                var callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)
                    ? node.parent.parent
                    : node.parent;
                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {
                    break;
                }
                var className = callExpression.arguments[0].getText();
                currentStructure.name = className;
                var types = callExpression.arguments[1];
                for (var i = 0; i < types.properties.length; i++) {
                    var prop = types.properties[i];
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {
                currentStructure.name = node.getText();
            }
            currentProperty = undefined;
            break;
    }
    ts.forEachChild(node, function (n) { return inspectNode(n, context, decoratorName); });
}
var parsedFiles;
function parseFiles(fileNames, decoratorName, context) {
    if (decoratorName === void 0) { decoratorName = "type"; }
    if (context === void 0) { context = new types_1.Context(); }
    /**
     * Re-set globalContext for each test case
     */
    if (globalContext !== context) {
        parsedFiles = {};
        globalContext = context;
    }
    fileNames.forEach(function (fileName) {
        var sourceFile;
        var sourceFileName;
        var fileNameAlternatives = [];
        if (!fileName.endsWith(".ts") &&
            !fileName.endsWith(".js") &&
            !fileName.endsWith(".mjs")) {
            fileNameAlternatives.push(fileName + ".ts");
            fileNameAlternatives.push(fileName + "/index.ts");
        }
        else {
            fileNameAlternatives.push(fileName);
        }
        for (var i = 0; i < fileNameAlternatives.length; i++) {
            try {
                sourceFileName = path.resolve(fileNameAlternatives[i]);
                if (parsedFiles[sourceFileName]) {
                    break;
                }
                sourceFile = ts.createSourceFile(sourceFileName, (0, fs_1.readFileSync)(sourceFileName).toString(), ts.ScriptTarget.Latest, true);
                parsedFiles[sourceFileName] = true;
                break;
            }
            catch (e) {
                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);
            }
        }
        if (sourceFile) {
            inspectNode(sourceFile, context, decoratorName);
        }
    });
    return context.getStructures();
}
exports.parseFiles = parseFiles;
//# sourceMappingURL=parser.js.map