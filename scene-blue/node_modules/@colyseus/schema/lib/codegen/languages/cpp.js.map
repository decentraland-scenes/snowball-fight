{"version":3,"file":"cpp.js","sourceRoot":"","sources":["../../../src/codegen/languages/cpp.ts"],"names":[],"mappings":"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","sourcesContent":["import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types\";\nimport { GenerateOptions } from \"../api\";\n\nconst typeMaps = {\n    \"string\": \"string\",\n    \"number\": \"varint_t\",\n    \"boolean\": \"bool\",\n    \"int8\": \"int8_t\",\n    \"uint8\": \"uint8_t\",\n    \"int16\": \"int16_t\",\n    \"uint16\": \"uint16_t\",\n    \"int32\": \"int32_t\",\n    \"uint32\": \"uint32_t\",\n    \"int64\": \"int64_t\",\n    \"uint64\": \"uint64_t\",\n    \"float32\": \"float32_t\",\n    \"float64\": \"float64_t\",\n}\n\nconst typeInitializer = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\n/**\n * C++ Code Generator\n */\n\nconst capitalize = (s) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\nconst distinct = (value, index, self) => self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hpp\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const propertiesPerType: {[type: string]: Property[]} = {};\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        if (!propertiesPerType[type]) {\n            propertiesPerType[type] = [];\n        }\n\n        propertiesPerType[type].push(property);\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const allProperties = getAllProperties(klass, allClasses);\n    const createInstanceMethod = (allRefs.length === 0) ? \"\" :\n    `\\tinline Schema* createInstance(std::type_index type) {\n\\t\\t${generateFieldIfElseChain(allRefs,\n    (property) => `type == typeid(${property.childType})`,\n    (property) => `return new ${property.childType}();`,\n    (property) => typeMaps[property.childType] === undefined)}\n\\t\\treturn ${klass.extends}::createInstance(type);\n\\t}`;\n\n    return `${getCommentHeader()}\n#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__\n#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1\n\n#include \"schema.h\"\n#include <typeinfo>\n#include <typeindex>\n\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `#include \"${childType}.hpp\"`).\n    join(\"\\n\")}\n\nusing namespace colyseus::schema;\n\n${namespace ? `namespace ${namespace} {` : \"\"}\nclass ${klass.name} : public ${klass.extends} {\npublic:\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n\n\\t${klass.name}() {\n\\t\\tthis->_indexes = ${generateAllIndexes(allProperties)};\n\\t\\tthis->_types = ${generateAllTypes(allProperties)};\n\\t\\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};\n\\t\\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};\n\\t}\n\n\\tvirtual ~${klass.name}() {\n\\t\\t${generateDestructors(allProperties).join(\"\\n\\t\\t\")}\n\\t}\n\nprotected:\n${Object.keys(propertiesPerType).map(type =>\n    generateGettersAndSetters(klass, type, propertiesPerType[type])).\n    join(\"\\n\")}\n\n${createInstanceMethod}\n};\n${namespace ? \"}\" : \"\"}\n\n#endif\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let property = \"\";\n    let langType: string;\n    let initializer = \"\";\n    let isPropPointer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}*>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}*>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n        isPropPointer = \"*\";\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${isPropPointer}${prop.name}`;\n\n    return `\\t${property} = ${initializer};`\n}\n\nfunction generateGettersAndSetters(klass: Class, type: string, properties: Property[]) {\n    let langType = typeMaps[type];\n    let typeCast = \"\";\n\n    const getMethodName = `get${capitalize(type)}`;\n    const setMethodName = `set${capitalize(type)}`;\n\n    if (type === \"ref\") {\n        langType = \"Schema*\";\n\n    } else if (type === \"array\") {\n        langType = `ArraySchema<char*> *`;\n        typeCast = `(ArraySchema<char*> *)`;\n\n    } else if (type === \"map\") {\n        langType = `MapSchema<char*> *`;\n        typeCast = `(MapSchema<char*> *)`;\n    }\n\n    return `\\tinline ${langType} ${getMethodName}(const string &field)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => `return ${typeCast}this->${property.name};`)}\n\\t\\treturn ${klass.extends}::${getMethodName}(field);\n\\t}\n\n\\tinline void ${setMethodName}(const string &field, ${langType} value)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => {\n        const isSchemaType = (typeMaps[property.childType] === undefined)\n\n        if (type === \"ref\") {\n            langType = `${property.childType}*`;\n            typeCast = (isSchemaType)\n                ? `(${property.childType}*)`\n                : `/* bug? */`;\n\n        } else if (type === \"array\") {\n            typeCast = (isSchemaType)\n                ? `(ArraySchema<${property.childType}*> *)`\n                : `(ArraySchema<${typeMaps[property.childType]}> *)`;\n\n        } else if (type === \"map\") {\n            typeCast = (isSchemaType)\n                ? `(MapSchema<${property.childType}*> *)`\n                : `(MapSchema<${typeMaps[property.childType]}> *)`;\n        }\n\n        return `this->${property.name} = ${typeCast}value;\\n\\t\\t\\treturn;`\n    })}\n\\t\\treturn ${klass.extends}::${setMethodName}(field, value);\n\\t}`;\n}\n\nfunction generateFieldIfElseChain(\n    properties: Property[],\n    ifCallback: (property: Property) => string,\n    callback: (property: Property) => string,\n    filter: (property: Property) => boolean = (_) => true,\n) {\n    let chain = \"\";\n\n    const uniqueChecks: string[] = [];\n    properties.filter(filter).forEach((property, i) => {\n        const check = ifCallback(property);\n        if (uniqueChecks.indexOf(check) === -1) {\n            uniqueChecks.push(check);\n\n        } else {\n            return;\n        }\n\n        if (i === 0) { chain += \"if \" } else { chain += \" else if \" }\n        chain += `(${check})\n\\t\\t{\n\\t\\t\\t${callback(property)}\\n\n\\t\\t}`\n    });\n\n    return chain;\n}\n\nfunction generateAllIndexes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.name}\"}`).join(\", \")}}`\n\n}\n\nfunction generateAllTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.type}\"}`).join(\", \")}}`\n}\n\nfunction generateAllChildSchemaTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (property.childType && typeMaps[property.childType] === undefined) {\n            return `{${i}, typeid(${property.childType})}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateAllChildPrimitiveTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (typeMaps[property.childType] !== undefined) {\n            return `{${i}, \"${property.childType}\"}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateDestructors(properties: Property[]) {\n    return properties.map((property, i) => {\n        if (property.childType) {\n            return `delete this->${property.name};`;\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null);\n}\n\nfunction getAllProperties (klass: Class, allClasses: Class[]) {\n    let properties: Property[] = [];\n\n    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {\n        properties = properties.concat(klass.properties);\n    });\n\n    return properties;\n}"]}