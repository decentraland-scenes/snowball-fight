"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInheritanceTree = exports.Property = exports.Class = exports.Interface = exports.Context = exports.getCommentHeader = void 0;
var fs = require("fs");
var VERSION = JSON.parse(fs.readFileSync(__dirname + "/../../package.json").toString()).version;
var COMMENT_HEADER = "\nTHIS FILE HAS BEEN GENERATED AUTOMATICALLY\nDO NOT CHANGE IT MANUALLY UNLESS YOU KNOW WHAT YOU'RE DOING\n\nGENERATED USING @colyseus/schema " + VERSION + "\n";
function getCommentHeader(singleLineComment) {
    if (singleLineComment === void 0) { singleLineComment = "//"; }
    return "" + COMMENT_HEADER.split("\n").map(function (line) { return singleLineComment + " " + line; }).join("\n");
}
exports.getCommentHeader = getCommentHeader;
var Context = /** @class */ (function () {
    function Context() {
        this.classes = [];
        this.interfaces = [];
    }
    Context.prototype.getStructures = function () {
        var _this = this;
        return {
            classes: this.classes.filter(function (klass) {
                if (_this.isSchemaClass(klass)) {
                    return true;
                }
                else {
                    var parentClass = klass;
                    while (parentClass = _this.getParentClass(parentClass)) {
                        if (_this.isSchemaClass(parentClass)) {
                            return true;
                        }
                    }
                }
                return false;
            }),
            interfaces: this.interfaces,
        };
    };
    Context.prototype.addStructure = function (structure) {
        structure.context = this;
        if (structure instanceof Class) {
            this.classes.push(structure);
        }
        else if (structure instanceof Interface) {
            this.interfaces.push(structure);
        }
    };
    Context.prototype.getParentClass = function (klass) {
        return this.classes.find(function (c) { return c.name === klass.extends; });
    };
    Context.prototype.isSchemaClass = function (klass) {
        var isSchema = false;
        var currentClass = klass;
        while (!isSchema && currentClass) {
            isSchema = currentClass.extends === "Schema";
            currentClass = this.getParentClass(currentClass);
        }
        return isSchema;
    };
    return Context;
}());
exports.Context = Context;
var Interface = /** @class */ (function () {
    function Interface() {
        this.properties = [];
    }
    Interface.prototype.addProperty = function (property) {
        if (property.type.indexOf("[]") >= 0) {
            // is array!
            property.childType = property.type.match(/([^\[]+)/i)[1];
            property.type = "array";
            this.properties.push(property);
        }
        else {
            this.properties.push(property);
        }
    };
    return Interface;
}());
exports.Interface = Interface;
var Class = /** @class */ (function () {
    function Class() {
        this.properties = [];
    }
    Class.prototype.addProperty = function (property) {
        property.index = this.properties.length;
        this.properties.push(property);
    };
    Class.prototype.postProcessing = function () {
        /**
         * Ensure the proprierties `index` are correct using inheritance
         */
        var parentKlass = this;
        while (parentKlass &&
            (parentKlass = this.context.classes.find(function (k) { return k.name === parentKlass.extends; }))) {
            this.properties.forEach(function (prop) {
                prop.index += parentKlass.properties.length;
            });
        }
    };
    return Class;
}());
exports.Class = Class;
var Property = /** @class */ (function () {
    function Property() {
    }
    return Property;
}());
exports.Property = Property;
function getInheritanceTree(klass, allClasses, includeSelf) {
    if (includeSelf === void 0) { includeSelf = true; }
    var currentClass = klass;
    var inheritanceTree = [];
    if (includeSelf) {
        inheritanceTree.push(currentClass);
    }
    while (currentClass.extends !== "Schema") {
        currentClass = allClasses.find(function (klass) { return klass.name == currentClass.extends; });
        inheritanceTree.push(currentClass);
    }
    return inheritanceTree;
}
exports.getInheritanceTree = getInheritanceTree;
//# sourceMappingURL=types.js.map