"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
var spec_1 = require("./spec");
var annotations_1 = require("./annotations");
var encode = require("./encoding/encode");
var decode = require("./encoding/decode");
var ArraySchema_1 = require("./types/ArraySchema");
var MapSchema_1 = require("./types/MapSchema");
var CollectionSchema_1 = require("./types/CollectionSchema");
var SetSchema_1 = require("./types/SetSchema");
var ChangeTree_1 = require("./changes/ChangeTree");
var EventEmitter_1 = require("./events/EventEmitter");
var filters_1 = require("./filters");
var types_1 = require("./types");
var EncodeSchemaError = /** @class */ (function (_super) {
    __extends(EncodeSchemaError, _super);
    function EncodeSchemaError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EncodeSchemaError;
}(Error));
function assertType(value, type, klass, field) {
    var typeofTarget;
    var allowNull = false;
    switch (type) {
        case "number":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
        case "int64":
        case "uint64":
        case "float32":
        case "float64":
            typeofTarget = "number";
            if (isNaN(value)) {
                console.log("trying to encode \"NaN\" in " + klass.constructor.name + "#" + field);
            }
            break;
        case "string":
            typeofTarget = "string";
            allowNull = true;
            break;
        case "boolean":
            // boolean is always encoded as true/false based on truthiness
            return;
    }
    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
        var foundValue = "'" + JSON.stringify(value) + "'" + ((value && value.constructor && " (" + value.constructor.name + ")") || '');
        throw new EncodeSchemaError("a '" + typeofTarget + "' was expected, but " + foundValue + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function assertInstanceType(value, type, klass, field) {
    if (!(value instanceof type)) {
        throw new EncodeSchemaError("a '" + type.name + "' was expected, but '" + value.constructor.name + "' was provided in " + klass.constructor.name + "#" + field);
    }
}
function encodePrimitiveType(type, bytes, value, klass, field) {
    assertType(value, type, klass, field);
    var encodeFunc = encode[type];
    if (encodeFunc) {
        encodeFunc(bytes, value);
    }
    else {
        throw new EncodeSchemaError("a '" + type + "' was expected, but " + value + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function decodePrimitiveType(type, bytes, it) {
    return decode[type](bytes, it);
}
/**
 * Schema encoder / decoder
 */
var Schema = /** @class */ (function () {
    // allow inherited classes to have a constructor
    function Schema() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // fix enumerability of fields for end-user
        Object.defineProperties(this, {
            $changes: {
                value: new ChangeTree_1.ChangeTree(this, undefined, new ChangeTree_1.Root()),
                enumerable: false,
                writable: true
            },
            $listeners: {
                value: {},
                enumerable: false,
                writable: true
            },
        });
        var descriptors = this._definition.descriptors;
        if (descriptors) {
            Object.defineProperties(this, descriptors);
        }
        //
        // Assign initial values
        //
        if (args[0]) {
            this.assign(args[0]);
        }
    }
    Schema.onError = function (e) {
        console.error(e);
    };
    Schema.is = function (type) {
        return (type['_definition'] &&
            type['_definition'].schema !== undefined);
    };
    Schema.prototype.assign = function (props) {
        Object.assign(this, props);
        return this;
    };
    Object.defineProperty(Schema.prototype, "_definition", {
        get: function () { return this.constructor._definition; },
        enumerable: false,
        configurable: true
    });
    Schema.prototype.listen = function (attr, callback) {
        var _this = this;
        if (!this.$listeners[attr]) {
            this.$listeners[attr] = new EventEmitter_1.EventEmitter_();
        }
        this.$listeners[attr].register(callback);
        // return un-register callback.
        return function () {
            return _this.$listeners[attr].remove(callback);
        };
    };
    Schema.prototype.decode = function (bytes, it, ref, allChanges) {
        if (it === void 0) { it = { offset: 0 }; }
        if (ref === void 0) { ref = this; }
        if (allChanges === void 0) { allChanges = new Map(); }
        var $root = this.$changes.root;
        var totalBytes = bytes.length;
        var refId = 0;
        var changes = [];
        $root.refs.set(refId, this);
        allChanges.set(refId, changes);
        while (it.offset < totalBytes) {
            var byte = bytes[it.offset++];
            if (byte == spec_1.SWITCH_TO_STRUCTURE) {
                refId = decode.number(bytes, it);
                var nextRef = $root.refs.get(refId);
                //
                // Trying to access a reference that haven't been decoded yet.
                //
                if (!nextRef) {
                    throw new Error("\"refId\" not found: " + refId);
                }
                ref = nextRef;
                // create empty list of changes for this refId.
                changes = [];
                allChanges.set(refId, changes);
                continue;
            }
            var changeTree = ref['$changes'];
            var isSchema = (ref['_definition'] !== undefined);
            var operation = (isSchema)
                ? (byte >> 6) << 6 // "compressed" index + operation
                : byte; // "uncompressed" index + operation (array/map items)
            if (operation === spec_1.OPERATION.CLEAR) {
                //
                // TODO: refactor me!
                // The `.clear()` method is calling `$root.removeRef(refId)` for
                // each item inside this collection
                //
                ref.clear(true);
                continue;
            }
            var fieldIndex = (isSchema)
                ? byte % (operation || 255) // if "REPLACE" operation (0), use 255
                : decode.number(bytes, it);
            var fieldName = (isSchema)
                ? (ref['_definition'].fieldsByIndex[fieldIndex])
                : "";
            var type = changeTree.getType(fieldIndex);
            var value = void 0;
            var previousValue = void 0;
            var dynamicIndex = void 0;
            if (!isSchema) {
                previousValue = ref['getByIndex'](fieldIndex);
                if ((operation & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) { // ADD or DELETE_AND_ADD
                    dynamicIndex = (ref instanceof MapSchema_1.MapSchema)
                        ? decode.string(bytes, it)
                        : fieldIndex;
                    ref['setIndex'](fieldIndex, dynamicIndex);
                }
                else {
                    // here
                    dynamicIndex = ref['getIndex'](fieldIndex);
                }
            }
            else {
                previousValue = ref["_" + fieldName];
            }
            //
            // Delete operations
            //
            if ((operation & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE) {
                if (operation !== spec_1.OPERATION.DELETE_AND_ADD) {
                    ref['deleteByIndex'](fieldIndex);
                }
                // Flag `refId` for garbage collection.
                if (previousValue && previousValue['$changes']) {
                    $root.removeRef(previousValue['$changes'].refId);
                }
                value = null;
            }
            if (fieldName === undefined) {
                console.warn("@colyseus/schema: definition mismatch");
                //
                // keep skipping next bytes until reaches a known structure
                // by local decoder.
                //
                var nextIterator = { offset: it.offset };
                while (it.offset < totalBytes) {
                    if (decode.switchStructureCheck(bytes, it)) {
                        nextIterator.offset = it.offset + 1;
                        if ($root.refs.has(decode.number(bytes, nextIterator))) {
                            break;
                        }
                    }
                    it.offset++;
                }
                continue;
            }
            else if (operation === spec_1.OPERATION.DELETE) {
                //
                // FIXME: refactor me.
                // Don't do anything.
                //
            }
            else if (Schema.is(type)) {
                var refId_1 = decode.number(bytes, it);
                value = $root.refs.get(refId_1);
                if (operation !== spec_1.OPERATION.REPLACE) {
                    var childType = this.getSchemaType(bytes, it, type);
                    if (!value) {
                        value = this.createTypeInstance(childType);
                        value.$changes.refId = refId_1;
                        if (previousValue) {
                            value.onChange = previousValue.onChange;
                            value.onRemove = previousValue.onRemove;
                            value.$listeners = previousValue.$listeners;
                            if (previousValue['$changes'].refId &&
                                refId_1 !== previousValue['$changes'].refId) {
                                $root.removeRef(previousValue['$changes'].refId);
                            }
                        }
                    }
                    $root.addRef(refId_1, value, (value !== previousValue));
                }
            }
            else if (typeof (type) === "string") {
                //
                // primitive value (number, string, boolean, etc)
                //
                value = decodePrimitiveType(type, bytes, it);
            }
            else {
                var typeDef = (0, types_1.getType)(Object.keys(type)[0]);
                var refId_2 = decode.number(bytes, it);
                var valueRef = ($root.refs.has(refId_2))
                    ? previousValue || $root.refs.get(refId_2)
                    : new typeDef.constructor();
                value = valueRef.clone(true);
                value.$changes.refId = refId_2;
                // preserve schema callbacks
                if (previousValue) {
                    value.onAdd = previousValue.onAdd;
                    value.onRemove = previousValue.onRemove;
                    value.onChange = previousValue.onChange;
                    if (previousValue['$changes'].refId &&
                        refId_2 !== previousValue['$changes'].refId) {
                        $root.removeRef(previousValue['$changes'].refId);
                        //
                        // Trigger onRemove if structure has been replaced.
                        //
                        var deletes = [];
                        var entries = previousValue.entries();
                        var iter = void 0;
                        while ((iter = entries.next()) && !iter.done) {
                            var _a = __read(iter.value, 2), key = _a[0], value_1 = _a[1];
                            deletes.push({
                                op: spec_1.OPERATION.DELETE,
                                field: key,
                                value: undefined,
                                previousValue: value_1,
                            });
                        }
                        allChanges.set(previousValue['$changes'].refId, deletes);
                    }
                }
                $root.addRef(refId_2, value, (valueRef !== previousValue));
                //
                // TODO: deprecate proxies on next version.
                // get proxy to target value.
                //
                if (typeDef.getProxy) {
                    value = typeDef.getProxy(value);
                }
            }
            var hasChange = (previousValue !== value);
            if (value !== null &&
                value !== undefined) {
                if (value['$changes']) {
                    value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);
                }
                if (ref instanceof Schema) {
                    ref[fieldName] = value;
                    //
                    // FIXME: use `_field` instead of `field`.
                    //
                    // `field` is going to use the setter of the PropertyDescriptor
                    // and create a proxy for array/map. This is only useful for
                    // backwards-compatibility with @colyseus/schema@0.5.x
                    //
                    // // ref[_field] = value;
                }
                else if (ref instanceof MapSchema_1.MapSchema) {
                    // const key = ref['$indexes'].get(field);
                    var key = dynamicIndex;
                    // ref.set(key, value);
                    ref['$items'].set(key, value);
                }
                else if (ref instanceof ArraySchema_1.ArraySchema) {
                    // const key = ref['$indexes'][field];
                    // console.log("SETTING FOR ArraySchema =>", { field, key, value });
                    // ref[key] = value;
                    ref.setAt(fieldIndex, value);
                }
                else if (ref instanceof CollectionSchema_1.CollectionSchema) {
                    var index = ref.add(value);
                    ref['setIndex'](fieldIndex, index);
                }
                else if (ref instanceof SetSchema_1.SetSchema) {
                    var index = ref.add(value);
                    if (index !== false) {
                        ref['setIndex'](fieldIndex, index);
                    }
                }
            }
            if (hasChange
            // &&
            // (
            //     this.onChange || ref.$listeners[field]
            // )
            ) {
                changes.push({
                    op: operation,
                    field: fieldName,
                    dynamicIndex: dynamicIndex,
                    value: value,
                    previousValue: previousValue,
                });
            }
        }
        this._triggerChanges(allChanges);
        // drop references of unused schemas
        $root.garbageCollectDeletedRefs();
        return allChanges;
    };
    Schema.prototype.encode = function (encodeAll, bytes, useFilters) {
        if (encodeAll === void 0) { encodeAll = false; }
        if (bytes === void 0) { bytes = []; }
        if (useFilters === void 0) { useFilters = false; }
        var rootChangeTree = this.$changes;
        var refIdsVisited = new WeakSet();
        var changeTrees = [rootChangeTree];
        var numChangeTrees = 1;
        for (var i = 0; i < numChangeTrees; i++) {
            var changeTree = changeTrees[i];
            var ref = changeTree.ref;
            var isSchema = (ref instanceof Schema);
            // Generate unique refId for the ChangeTree.
            changeTree.ensureRefId();
            // mark this ChangeTree as visited.
            refIdsVisited.add(changeTree);
            // root `refId` is skipped.
            if (changeTree !== rootChangeTree &&
                (changeTree.changed || encodeAll)) {
                encode.uint8(bytes, spec_1.SWITCH_TO_STRUCTURE);
                encode.number(bytes, changeTree.refId);
            }
            var changes = (encodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var operation = (encodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                var fieldIndex = operation.index;
                var field = (isSchema)
                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]
                    : fieldIndex;
                // cache begin index if `useFilters`
                var beginIndex = bytes.length;
                // encode field index + operation
                if (operation.op !== spec_1.OPERATION.TOUCH) {
                    if (isSchema) {
                        //
                        // Compress `fieldIndex` + `operation` into a single byte.
                        // This adds a limitaion of 64 fields per Schema structure
                        //
                        encode.uint8(bytes, (fieldIndex | operation.op));
                    }
                    else {
                        encode.uint8(bytes, operation.op);
                        // custom operations
                        if (operation.op === spec_1.OPERATION.CLEAR) {
                            continue;
                        }
                        // indexed operations
                        encode.number(bytes, fieldIndex);
                    }
                }
                //
                // encode "alias" for dynamic fields (maps)
                //
                if (!isSchema &&
                    (operation.op & spec_1.OPERATION.ADD) == spec_1.OPERATION.ADD // ADD or DELETE_AND_ADD
                ) {
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(bytes, dynamicIndex);
                    }
                }
                if (operation.op === spec_1.OPERATION.DELETE) {
                    //
                    // TODO: delete from filter cache data.
                    //
                    // if (useFilters) {
                    //     delete changeTree.caches[fieldIndex];
                    // }
                    continue;
                }
                // const type = changeTree.childType || ref._schema[field];
                var type = changeTree.getType(fieldIndex);
                // const type = changeTree.getType(fieldIndex);
                var value = changeTree.getValue(fieldIndex);
                // Enqueue ChangeTree to be visited
                if (value &&
                    value['$changes'] &&
                    !refIdsVisited.has(value['$changes'])) {
                    changeTrees.push(value['$changes']);
                    value['$changes'].ensureRefId();
                    numChangeTrees++;
                }
                if (operation.op === spec_1.OPERATION.TOUCH) {
                    continue;
                }
                if (Schema.is(type)) {
                    assertInstanceType(value, type, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                    // Try to encode inherited TYPE_ID if it's an ADD operation.
                    if ((operation.op & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) {
                        this.tryEncodeTypeId(bytes, type, value.constructor);
                    }
                }
                else if (typeof (type) === "string") {
                    //
                    // Primitive values
                    //
                    encodePrimitiveType(type, bytes, value, ref, field);
                }
                else {
                    //
                    // Custom type (MapSchema, ArraySchema, etc)
                    //
                    var definition = (0, types_1.getType)(Object.keys(type)[0]);
                    //
                    // ensure a ArraySchema has been provided
                    //
                    assertInstanceType(ref["_" + field], definition.constructor, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                }
                if (useFilters) {
                    // cache begin / end index
                    changeTree.cache(fieldIndex, bytes.slice(beginIndex));
                }
            }
            if (!encodeAll && !useFilters) {
                changeTree.discard();
            }
        }
        return bytes;
    };
    Schema.prototype.encodeAll = function (useFilters) {
        return this.encode(true, [], useFilters);
    };
    Schema.prototype.applyFilters = function (client, encodeAll) {
        var _a, _b;
        if (encodeAll === void 0) { encodeAll = false; }
        var root = this;
        var refIdsDissallowed = new Set();
        var $filterState = filters_1.ClientState.get(client);
        var changeTrees = [this.$changes];
        var numChangeTrees = 1;
        var filteredBytes = [];
        var _loop_1 = function (i) {
            var changeTree = changeTrees[i];
            if (refIdsDissallowed.has(changeTree.refId)) {
                return "continue";
            }
            var ref = changeTree.ref;
            var isSchema = ref instanceof Schema;
            encode.uint8(filteredBytes, spec_1.SWITCH_TO_STRUCTURE);
            encode.number(filteredBytes, changeTree.refId);
            var clientHasRefId = $filterState.refIds.has(changeTree);
            var isEncodeAll = (encodeAll || !clientHasRefId);
            // console.log("REF:", ref.constructor.name);
            // console.log("Encode all?", isEncodeAll);
            //
            // include `changeTree` on list of known refIds by this client.
            //
            $filterState.addRefId(changeTree);
            var containerIndexes = $filterState.containerIndexes.get(changeTree);
            var changes = (isEncodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            //
            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes
            // - see "DELETE a field of Schema" test case.
            //
            if (!encodeAll &&
                isSchema &&
                ref._definition.indexesWithFilters) {
                var indexesWithFilters = ref._definition.indexesWithFilters;
                indexesWithFilters.forEach(function (indexWithFilter) {
                    if (!containerIndexes.has(indexWithFilter) &&
                        changeTree.allChanges.has(indexWithFilter)) {
                        if (isEncodeAll) {
                            changes.push(indexWithFilter);
                        }
                        else {
                            changes.push({ op: spec_1.OPERATION.ADD, index: indexWithFilter, });
                        }
                    }
                });
            }
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var change = (isEncodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                // custom operations
                if (change.op === spec_1.OPERATION.CLEAR) {
                    encode.uint8(filteredBytes, change.op);
                    continue;
                }
                var fieldIndex = change.index;
                //
                // Deleting fields: encode the operation + field index
                //
                if (change.op === spec_1.OPERATION.DELETE) {
                    //
                    // DELETE operations also need to go through filtering.
                    //
                    // TODO: cache the previous value so we can access the value (primitive or `refId`)
                    // (check against `$filterState.refIds`)
                    //
                    if (isSchema) {
                        encode.uint8(filteredBytes, change.op | fieldIndex);
                    }
                    else {
                        encode.uint8(filteredBytes, change.op);
                        encode.number(filteredBytes, fieldIndex);
                    }
                    continue;
                }
                // indexed operation
                var value = changeTree.getValue(fieldIndex);
                var type = changeTree.getType(fieldIndex);
                if (isSchema) {
                    // Is a Schema!
                    var filter = (ref._definition.filters &&
                        ref._definition.filters[fieldIndex]);
                    if (filter && !filter.call(ref, client, value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                            ;
                        }
                        continue;
                    }
                }
                else {
                    // Is a collection! (map, array, etc.)
                    var parent = changeTree.parent;
                    var filter = changeTree.getChildrenFilter();
                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                        }
                        continue;
                    }
                }
                // visit child ChangeTree on further iteration.
                if (value['$changes']) {
                    changeTrees.push(value['$changes']);
                    numChangeTrees++;
                }
                //
                // Copy cached bytes
                //
                if (change.op !== spec_1.OPERATION.TOUCH) {
                    //
                    // TODO: refactor me!
                    //
                    if (change.op === spec_1.OPERATION.ADD || isSchema) {
                        //
                        // use cached bytes directly if is from Schema type.
                        //
                        filteredBytes.push.apply(filteredBytes, (_a = changeTree.caches[fieldIndex]) !== null && _a !== void 0 ? _a : []);
                        containerIndexes.add(fieldIndex);
                    }
                    else {
                        if (containerIndexes.has(fieldIndex)) {
                            //
                            // use cached bytes if already has the field
                            //
                            filteredBytes.push.apply(filteredBytes, (_b = changeTree.caches[fieldIndex]) !== null && _b !== void 0 ? _b : []);
                        }
                        else {
                            //
                            // force ADD operation if field is not known by this client.
                            //
                            containerIndexes.add(fieldIndex);
                            encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                            encode.number(filteredBytes, fieldIndex);
                            if (ref instanceof MapSchema_1.MapSchema) {
                                //
                                // MapSchema dynamic key
                                //
                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                encode.string(filteredBytes, dynamicIndex);
                            }
                            if (value['$changes']) {
                                encode.number(filteredBytes, value['$changes'].refId);
                            }
                            else {
                                // "encodePrimitiveType" without type checking.
                                // the type checking has been done on the first .encode() call.
                                encode[type](filteredBytes, value);
                            }
                        }
                    }
                }
                else if (value['$changes'] && !isSchema) {
                    //
                    // TODO:
                    // - track ADD/REPLACE/DELETE instances on `$filterState`
                    // - do NOT always encode dynamicIndex for MapSchema.
                    //   (If client already has that key, only the first index is necessary.)
                    //
                    encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                    encode.number(filteredBytes, fieldIndex);
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(filteredBytes, dynamicIndex);
                    }
                    encode.number(filteredBytes, value['$changes'].refId);
                }
            }
            ;
        };
        for (var i = 0; i < numChangeTrees; i++) {
            _loop_1(i);
        }
        return filteredBytes;
    };
    Schema.prototype.clone = function () {
        var cloned = new (this.constructor);
        var schema = this._definition.schema;
        for (var field in schema) {
            if (typeof (this[field]) === "object" &&
                typeof (this[field].clone) === "function") {
                // deep clone
                cloned[field] = this[field].clone();
            }
            else {
                // primitive values
                cloned[field] = this[field];
            }
        }
        return cloned;
    };
    Schema.prototype.triggerAll = function () {
        // skip if haven't received any remote refs yet.
        if (this.$changes.root.refs.size === 0) {
            return;
        }
        var allChanges = new Map();
        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);
        try {
            Schema.prototype._triggerChanges.call(this, allChanges);
        }
        catch (e) {
            Schema.onError(e);
        }
    };
    Schema.prototype.toJSON = function () {
        var schema = this._definition.schema;
        var deprecated = this._definition.deprecated;
        var obj = {};
        for (var field in schema) {
            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== "undefined") {
                obj[field] = (typeof (this[field]['toJSON']) === "function")
                    ? this[field]['toJSON']()
                    : this["_" + field];
            }
        }
        return obj;
    };
    Schema.prototype.discardAllChanges = function () {
        this.$changes.discardAll();
    };
    Schema.prototype.getByIndex = function (index) {
        return this[this._definition.fieldsByIndex[index]];
    };
    Schema.prototype.deleteByIndex = function (index) {
        this[this._definition.fieldsByIndex[index]] = undefined;
    };
    Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {
        if (type._typeid !== targetType._typeid) {
            encode.uint8(bytes, spec_1.TYPE_ID);
            encode.number(bytes, targetType._typeid);
        }
    };
    Schema.prototype.getSchemaType = function (bytes, it, defaultType) {
        var type;
        if (bytes[it.offset] === spec_1.TYPE_ID) {
            it.offset++;
            type = this.constructor._context.get(decode.number(bytes, it));
        }
        return type || defaultType;
    };
    Schema.prototype.createTypeInstance = function (type) {
        var instance = new type();
        // assign root on $changes
        instance.$changes.root = this.$changes.root;
        return instance;
    };
    Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {
        if (allChanges.has(ref['$changes'].refId)) {
            return;
        }
        var changes = [];
        allChanges.set(ref['$changes'].refId || 0, changes);
        if (ref instanceof Schema) {
            var schema = ref._definition.schema;
            for (var fieldName in schema) {
                var _field = "_" + fieldName;
                var value = ref[_field];
                if (value !== undefined) {
                    changes.push({
                        op: spec_1.OPERATION.ADD,
                        field: fieldName,
                        value: value,
                        previousValue: undefined
                    });
                    if (value['$changes'] !== undefined) {
                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                    }
                }
            }
        }
        else {
            var entries = ref.entries();
            var iter = void 0;
            while ((iter = entries.next()) && !iter.done) {
                var _a = __read(iter.value, 2), key = _a[0], value = _a[1];
                changes.push({
                    op: spec_1.OPERATION.ADD,
                    field: key,
                    dynamicIndex: key,
                    value: value,
                    previousValue: undefined,
                });
                if (value['$changes'] !== undefined) {
                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                }
            }
        }
    };
    Schema.prototype._triggerChanges = function (allChanges) {
        var _this = this;
        allChanges.forEach(function (changes, refId) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (changes.length > 0) {
                var ref = _this.$changes.root.refs.get(refId);
                var isSchema = ref instanceof Schema;
                for (var i = 0; i < changes.length; i++) {
                    var change = changes[i];
                    var listener = ref['$listeners'] && ref['$listeners'][change.field];
                    if (!isSchema) {
                        if (change.op === spec_1.OPERATION.ADD && change.previousValue === undefined) {
                            (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);
                        }
                        else if (change.op === spec_1.OPERATION.DELETE) {
                            //
                            // FIXME: `previousValue` should always be avaiiable.
                            // ADD + DELETE operations are still encoding DELETE operation.
                            //
                            if (change.previousValue !== undefined) {
                                (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);
                            }
                        }
                        else if (change.op === spec_1.OPERATION.DELETE_AND_ADD) {
                            if (change.previousValue !== undefined) {
                                (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);
                            }
                            (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);
                        }
                        else if (change.op === spec_1.OPERATION.REPLACE ||
                            change.value !== change.previousValue) {
                            (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);
                        }
                    }
                    //
                    // trigger onRemove on child structure.
                    //
                    if ((change.op & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE &&
                        change.previousValue instanceof Schema &&
                        change.previousValue.onRemove) {
                        change.previousValue.onRemove();
                    }
                    if (listener) {
                        try {
                            listener.invoke(change.value, change.previousValue);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
                if (isSchema) {
                    if (ref.onChange) {
                        try {
                            ref.onChange(changes);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
            }
        });
    };
    Schema._definition = annotations_1.SchemaDefinition.create();
    return Schema;
}());
exports.Schema = Schema;
//# sourceMappingURL=Schema.js.map