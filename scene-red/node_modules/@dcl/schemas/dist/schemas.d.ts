import Ajv from 'ajv';
import { ErrorObject } from 'ajv';
import { JSONSchemaType } from 'ajv';

/**
 * Common structure to use types as values in TS.
 * @public
 */
export declare type AbstractTypedSchema<T> = {
    schema: JSONSchema<T>;
    validate: ValidateFunction<T>;
};

/** @internal */
declare type Actions = typeof SCENE_UPDATE | typeof UPDATE;

export { Ajv }

/** @alpha */
declare type AssetJson = {
    id: string;
    assetType: string;
    name: string;
    description: string;
    thumbnail: string;
    model: string;
    category: WearableCategory;
    rarity: Rarity;
    bodyShape: AssetWearableGender;
};

/** @alpha */
declare namespace AssetJson {
    const schema: JSONSchema<AssetJson>;
    const validate: ValidateFunction<AssetJson>;
}

declare enum AssetWearableGender {
    MALE = "male",
    FEMALE = "female",
    BOTH = "both"
}

declare namespace AssetWearableGender {
    const schema: JSONSchema<AssetWearableGender>;
    const validate: ValidateFunction<AssetWearableGender>;
}

/**
 * Avatar represents a profile avatar
 * @alpha
 */
export declare type Avatar = {
    userId: string;
    name: string;
    description: string;
    ethAddress: EthAddress;
    version: number;
    tutorialStep: number;
    email?: string;
    blocked?: string[];
    muted?: string[];
    interests?: string[];
    hasClaimedName: boolean;
    avatar: AvatarInfo;
};

/**
 * Avatar
 * @alpha
 */
export declare namespace Avatar {
    const schema: JSONSchema<Avatar>;
    const validate: ValidateFunction<Avatar>;
}

/**
 * AvatarInfo
 * @alpha
 */
export declare type AvatarInfo = {
    bodyShape: WearableId;
    eyes: {
        color: Color3;
    };
    hair: {
        color: Color3;
    };
    skin: {
        color: Color3;
    };
    wearables: WearableId[];
    snapshots: Snapshots;
};

/**
 * AvatarInfo
 * @alpha
 */
export declare namespace AvatarInfo {
    const schema: JSONSchema<AvatarInfo>;
    const validate: ValidateFunction<AvatarInfo>;
}

export declare type Bid = {
    id: string;
    bidder: string;
    seller: string;
    price: string;
    fingerprint: string;
    status: ListingStatus;
    blockchainId: string;
    blockNumber: string;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    contractAddress: string;
    tokenId: string;
    network: Network;
    chainId: ChainId;
};

export declare namespace Bid {
    const schema: JSONSchema<Bid>;
    const validate: ValidateFunction<Bid>;
}

export declare type BidFilters = {
    first?: number;
    skip?: number;
    sortBy?: BidSortBy;
    bidder?: string;
    seller?: string;
    contractAddress?: string;
    tokenId?: string;
    status?: ListingStatus;
    network?: Network;
};

export declare enum BidSortBy {
    RECENTLY_OFFERED = "recently_offered",
    RECENTLY_UPDATED = "recently_updated",
    MOST_EXPENSIVE = "most_expensive"
}

export declare enum BodyShape {
    MALE = "BaseMale",
    FEMALE = "BaseFemale"
}

export declare namespace BodyShape {
    const schema: JSONSchema<BodyShape>;
    const validate: ValidateFunction<BodyShape>;
}

/**
 * Different supported chain ids
 * @alpha
 */
export declare enum ChainId {
    ETHEREUM_MAINNET = 1,
    ETHEREUM_ROPSTEN = 3,
    ETHEREUM_RINKEBY = 4,
    ETHEREUM_GOERLI = 5,
    ETHEREUM_KOVAN = 42,
    MATIC_MAINNET = 137,
    MATIC_MUMBAI = 80001
}

/**
 * @alpha
 */
export declare namespace ChainId {
    const schema: JSONSchema<ChainId>;
    const validate: ValidateFunction<ChainId>;
}

/**
 * Different supported chain names
 * @alpha
 */
export declare enum ChainName {
    ETHEREUM_MAINNET = "Ethereum Mainnet",
    ETHEREUM_ROPSTEN = "Ropsten",
    ETHEREUM_RINKEBY = "Rinkeby",
    ETHEREUM_GOERLI = "Goerli",
    ETHEREUM_KOVAN = "Kovan",
    MATIC_MAINNET = "Polygon",
    MATIC_MUMBAI = "Mumbai"
}

/**
 * @alpha
 */
export declare namespace ChainName {
    const schema: JSONSchema<ChainName>;
    const validate: ValidateFunction<ChainName>;
}

export declare type Collection = {
    urn: string;
    name: string;
    creator: string;
    contractAddress: string;
    isOnSale: boolean;
    size: number;
    createdAt: number;
    updatedAt: number;
    reviewedAt: number;
    network: Network;
    chainId: ChainId;
};

export declare namespace Collection {
    const schema: JSONSchema<Collection>;
    const validate: ValidateFunction<Collection>;
}

export declare type CollectionFilters = {
    first?: number;
    skip?: number;
    sortBy?: CollectionSortBy;
    name?: string;
    search?: string;
    creator?: string;
    contractAddress?: string;
    urn?: string;
    isOnSale?: boolean;
    network?: Network;
};

export declare enum CollectionSortBy {
    NEWEST = "newest",
    NAME = "name",
    RECENTLY_REVIEWED = "recently_reviewed",
    SIZE = "size"
}

/**
 * Color3 is a data type that describes a color using R, G and B components
 * @alpha
 */
export declare type Color3 = {
    r: number;
    g: number;
    b: number;
};

/**
 * Color3
 * @alpha
 */
export declare namespace Color3 {
    const schema: JSONSchema<Color3>;
    const validate: ValidateFunction<Color3>;
}

export declare type Contract = {
    name: string;
    address: string;
    category: NFTCategory;
    network: Network;
    chainId: ChainId;
};

export declare namespace Contract {
    const schema: JSONSchema<Contract>;
    const validate: ValidateFunction<Contract>;
}

export declare type ContractFilters = {
    category?: NFTCategory;
    network?: Network;
};

export declare enum ContractSortBy {
    NAME = "name"
}

/**
 * EthAddress is a data type that describes an Ethereum address
 * @alpha
 */
export declare type EthAddress = string;

/**
 * EthAddress
 * @alpha
 */
export declare namespace EthAddress {
    const schema: JSONSchema<EthAddress>;
    const validate: ValidateFunction<EthAddress>;
}

/** @alpha */
export declare type FeatureToggles = Record<string, 'enabled' | 'disabled'>;

/** @alpha */
export declare namespace FeatureToggles {
    const schema: JSONSchema<FeatureToggles>;
    const validate: ValidateFunction<FeatureToggles>;
}

/**
 * Generates a validator for a specific JSON schema of a type T
 * @public
 */
export declare function generateValidator<T>(schema: JSONSchema<T>): ValidateFunction<T>;

/**
 * Get chain id by chain name
 * @alpha
 */
export declare function getChainId(chainName: ChainName): ChainId | null;

/**
 * Get the chain name by chain id
 * @alpha
 */
export declare function getChainName(chainId: ChainId): ChainName | null;

/**
 * Get the chain name by chain id
 * @alpha
 */
export declare function getURNProtocol(chainId: ChainId): string;

/**
 * Get World
 * @alpha
 */
export declare function getWorld(): World;

/** @alpha */
export declare type I18N = {
    code: Locale;
    text: string;
};

/** @alpha */
export declare namespace I18N {
    const schema: JSONSchema<I18N>;
    const validate: ValidateFunction<I18N>;
}

/**
 * IPFSv2 is a data type that describes an IPFS v2 hash
 * @alpha
 */
export declare type IPFSv2 = string;

/**
 * IPFSv2
 * @alpha
 */
export declare namespace IPFSv2 {
    const schema: JSONSchema<IPFSv2>;
    const validate: ValidateFunction<IPFSv2>;
}

/**
 * Check if is inside World Limits
 * @alpha
 */
export declare function isInsideWorldLimits(x: number, y: number): boolean;

export declare type Item = {
    id: string;
    name: string;
    thumbnail: string;
    url: string;
    category: NFTCategory;
    contractAddress: string;
    itemId: string;
    rarity: Rarity;
    price: string;
    available: number;
    isOnSale: boolean;
    creator: string;
    createdAt: number;
    updatedAt: number;
    reviewedAt: number;
    soldAt: number;
    data: NFT['data'];
    network: Network;
    chainId: ChainId;
};

export declare namespace Item {
    const schema: JSONSchema<Item>;
    const validate: ValidateFunction<Item>;
}

export declare type ItemFilters = {
    first?: number;
    skip?: number;
    sortBy?: ItemSortBy;
    creator?: string;
    rarities?: Rarity[];
    isSoldOut?: boolean;
    isOnSale?: boolean;
    search?: string;
    isWearableHead?: boolean;
    isWearableAccessory?: boolean;
    wearableCategory?: WearableCategory;
    wearableGenders?: WearableGender[];
    contractAddress?: string;
    itemId?: string;
    network?: Network;
};

export declare enum ItemSortBy {
    NAME = "name",
    NEWEST = "newest",
    RECENTLY_REVIEWED = "recently_reviewed",
    RECENTLY_SOLD = "recently_sold",
    CHEAPEST = "cheapest"
}

/**
 * This type alias exist only to avoid accidental refactors involving names of ajv
 * @public
 */
export declare type JSONSchema<T> = JSONSchemaType<T>;

export declare enum ListingStatus {
    OPEN = "open",
    SOLD = "sold",
    CANCELLED = "cancelled"
}

export declare namespace ListingStatus {
    const schema: JSONSchema<ListingStatus>;
    const validate: ValidateFunction<ListingStatus>;
}

/** @alpha */
export declare enum Locale {
    EN = "en",
    ES = "es"
}

/** @alpha */
export declare namespace Locale {
    const schema: JSONSchema<Locale>;
    const validate: ValidateFunction<Locale>;
}

/** @internal */
declare type Messages = SceneUpdate | Update;

/**
 * Meta-transaction to be relayed
 * @alpha
 */
export declare type MetaTransaction = {
    from: string;
    params: [string, string];
};

/**
 * @alpha
 */
export declare namespace MetaTransaction {
    const schema: JSONSchema<MetaTransaction>;
    const validate: ValidateFunction<MetaTransaction>;
}

/** @alpha */
export declare type Metrics = {
    triangles: number;
    materials: number;
    textures: number;
    meshes: number;
    bodies: number;
    entities: number;
};

/** @alpha */
export declare namespace Metrics {
    const schema: JSONSchema<Metrics>;
    const validate: ValidateFunction<Metrics>;
}

export declare type Mint = {
    id: string;
    creator: string;
    beneficiary: string;
    minter: string;
    itemId: string;
    tokenId: string;
    issuedId: string;
    contractAddress: string;
    price: string | null;
    timestamp: number;
    network: Network;
    chainId: ChainId;
};

export declare namespace Mint {
    const schema: JSONSchema<Mint>;
    const validate: ValidateFunction<Mint>;
}

export declare type MintFilters = {
    first?: number;
    skip?: number;
    sortBy?: MintSortBy;
    creator?: string;
    beneficiary?: string;
    minter?: string;
    contractAddress?: string;
    itemId?: string;
    tokenId?: string;
    issuedId?: string;
    isSale?: boolean;
    network?: Network;
};

export declare enum MintSortBy {
    RECENTLY_MINTED = "recently_minted",
    MOST_EXPENSIVE = "most_expensive"
}

declare type MultiPosition = {
    x: number[];
    y: number[];
    z: number[];
};

/**
 * Different supported networks
 * @alpha
 */
export declare enum Network {
    ETHEREUM = "ETHEREUM",
    MATIC = "MATIC"
}

/**
 * @alpha
 */
export declare namespace Network {
    const schema: JSONSchema<Network>;
    const validate: ValidateFunction<Network>;
}

export declare type NFT = {
    id: string;
    contractAddress: string;
    tokenId: string;
    activeOrderId: string | null;
    owner: string;
    name: string;
    category: NFTCategory;
    image: string;
    url: string;
    issuedId: string | null;
    itemId: string | null;
    data: {
        parcel?: {
            x: string;
            y: string;
            description: string | null;
            estate: {
                tokenId: string;
                name: string;
            } | null;
        };
        estate?: {
            size: number;
            parcels: {
                x: number;
                y: number;
            }[];
            description: string | null;
        };
        wearable?: {
            description: string;
            category: WearableCategory;
            rarity: Rarity;
            bodyShapes: BodyShape[];
        };
        ens?: {
            subdomain: string;
        };
    };
    network: Network;
    chainId: ChainId;
    createdAt: number;
    updatedAt: number;
    soldAt: number;
};

export declare namespace NFT {
    const schema: JSONSchema<NFT>;
    const validate: ValidateFunction<NFT>;
}

export declare enum NFTCategory {
    PARCEL = "parcel",
    ESTATE = "estate",
    WEARABLE = "wearable",
    ENS = "ens"
}

export declare namespace NFTCategory {
    const schema: JSONSchema<NFTCategory>;
    const validate: ValidateFunction<NFTCategory>;
}

export declare type NFTFilters = {
    first?: number;
    skip?: number;
    sortBy?: NFTSortBy;
    category?: NFTCategory;
    owner?: string;
    isOnSale?: boolean;
    search?: string;
    itemRarities?: Rarity[];
    isLand?: boolean;
    isWearableHead?: boolean;
    isWearableAccessory?: boolean;
    wearableCategory?: WearableCategory;
    wearableGenders?: WearableGender[];
    contractAddresses?: string[];
    tokenId?: string;
    itemId?: string;
    network?: Network;
};

export declare enum NFTSortBy {
    NAME = "name",
    NEWEST = "newest",
    RECENTLY_LISTED = "recently_listed",
    RECENTLY_SOLD = "recently_sold",
    CHEAPEST = "cheapest"
}

export declare type Order = {
    id: string;
    contractAddress: string;
    tokenId: string;
    owner: string;
    buyer: string | null;
    price: string;
    status: ListingStatus;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    network: Network;
    chainId: ChainId;
};

export declare namespace Order {
    const schema: JSONSchema<Order>;
    const validate: ValidateFunction<Order>;
}

export declare type OrderFilters = {
    first?: number;
    skip?: number;
    sortBy?: OrderSortBy;
    owner?: string;
    buyer?: string;
    contractAddress?: string;
    tokenId?: string;
    status?: ListingStatus;
    network?: Network;
};

export declare enum OrderSortBy {
    RECENTLY_LISTED = "recently_listed",
    RECENTLY_UPDATED = "recently_updated",
    CHEAPEST = "cheapest"
}

/**
 * Profile containing one or multiple avatars
 * @alpha
 */
export declare type Profile = {
    avatars: Avatar[];
};

/**
 * Profile
 * @alpha
 */
export declare namespace Profile {
    const schema: JSONSchema<Profile>;
    const validate: ValidateFunction<Profile>;
}

declare enum ProjectType {
    SCENE = "scene",
    SMART_ITEM = "smart-item",
    PORTABLE_EXPERIENCE = "portable-experience"
}

declare namespace ProjectType {
    const schema: JSONSchema<ProjectType>;
    const validate: ValidateFunction<ProjectType>;
}

export declare enum Rarity {
    UNIQUE = "unique",
    MYTHIC = "mythic",
    LEGENDARY = "legendary",
    EPIC = "epic",
    RARE = "rare",
    UNCOMMON = "uncommon",
    COMMON = "common"
}

export declare namespace Rarity {
    const schema: JSONSchema<Rarity>;
    const validate: ValidateFunction<Rarity>;
    export function getMaxSupply(rarity: Rarity): number;
    export function getColor(rarity: Rarity): string;
    export function getGradient(rarity: Rarity): [string, string];
}

export declare type Sale = {
    id: string;
    type: SaleType;
    buyer: string;
    seller: string;
    itemId: string | null;
    tokenId: string;
    contractAddress: string;
    price: string;
    timestamp: number;
    txHash: string;
    network: Network;
    chainId: ChainId;
};

export declare namespace Sale {
    const schema: JSONSchema<Sale>;
    const validate: ValidateFunction<Sale>;
}

export declare type SaleFilters = {
    first?: number;
    skip?: number;
    sortBy?: SaleSortBy;
    type?: SaleType;
    category?: NFTCategory;
    buyer?: string;
    seller?: string;
    contractAddress?: string;
    itemId?: string;
    tokenId?: string;
    from?: number;
    to?: number;
    minPrice?: string;
    maxPrice?: string;
    network?: Network;
};

export declare enum SaleSortBy {
    RECENTLY_SOLD = "recently_sold",
    MOST_EXPENSIVE = "most_expensive"
}

export declare enum SaleType {
    ORDER = "order",
    BID = "bid",
    MINT = "mint"
}

export declare namespace SaleType {
    const schema: JSONSchema<SaleType>;
    const validate: ValidateFunction<SaleType>;
}

/** @alpha */
export declare type Scene = {
    main: string;
    scene: SceneParcels;
    display?: {
        title?: string;
        favicon?: string;
        description?: string;
        navmapThumbnail?: string;
    };
    owner?: string;
    contact?: {
        name?: string;
        email?: string;
        im?: string;
        url?: string;
    };
    tags?: string[];
    source?: Source;
    spawnPoints?: SpawnPoint[];
    requiredPermissions?: string[];
    featureToggles?: FeatureToggles;
};

/** @alpha */
export declare namespace Scene {
    const schema: JSONSchema<Scene>;
    const validate: ValidateFunction<Scene>;
}

/** @internal */
declare const SCENE_UPDATE = "SCENE_UPDATE";

/** @alpha */
export declare type SceneParcels = {
    base: string;
    parcels: string[];
};

/** @alpha */
export declare namespace SceneParcels {
    const schema: JSONSchema<SceneParcels>;
    const schemaValidator: ValidateFunction<SceneParcels>;
    const validate: ValidateFunction<SceneParcels>;
}

/** @internal */
declare type SceneUpdate = {
    type: typeof SCENE_UPDATE;
    payload: {
        sceneId: string;
        sceneType: string;
    };
};

/** @internal */
declare namespace SceneUpdate {
    const schema: JSONSchema<SceneUpdate>;
    const validate: ValidateFunction<SceneUpdate>;
}

declare namespace sdk {
    export {
        Actions,
        Messages,
        SCENE_UPDATE,
        SceneUpdate,
        UPDATE,
        Update,
        ProjectType,
        AssetJson
    }
}
export { sdk }

declare type SinglePosition = {
    x: number;
    y: number;
    z: number;
};

/**
 * Snapshots
 * @alpha
 */
export declare type Snapshots = {
    face: IPFSv2;
    face256: IPFSv2;
    face128: IPFSv2;
    body: IPFSv2;
};

/**
 * Snapshots
 * @alpha
 */
export declare namespace Snapshots {
    const schema: JSONSchema<Snapshots>;
    const validate: ValidateFunction<Snapshots>;
}

/** @alpha */
export declare type Source = {
    version?: number;
    origin: string;
    projectId: string;
    point?: {
        x: number;
        y: number;
    };
    rotation?: 'north' | 'east' | 'south' | 'west';
    layout?: {
        rows: number;
        cols: number;
    };
    isEmpty?: boolean;
};

/** @alpha */
export declare namespace Source {
    const schema: JSONSchema<Source>;
    const validate: ValidateFunction<Source>;
}

/** @alpha */
export declare type SpawnPoint = {
    name?: string;
    position: SinglePosition | MultiPosition;
    default?: boolean;
    cameraTarget?: SinglePosition;
};

/** @alpha */
export declare namespace SpawnPoint {
    const schema: JSONSchema<SpawnPoint>;
    const validate: ValidateFunction<SpawnPoint>;
}

export declare type Store = {
    id: string;
    owner: string;
    description: string;
    links: {
        name: string;
        url: string;
    }[];
    images: {
        name: string;
        file: string;
    }[];
    version: number;
};

export declare namespace Store {
    const schema: JSONSchema<Store>;
    const validate: ValidateFunction<Store>;
}

/** @internal @deprecated */
declare const UPDATE = "update";

/** @internal @deprecated */
declare type Update = {
    type: typeof UPDATE;
};

/** @internal @deprecated */
declare namespace Update {
    const schema: JSONSchema<Update>;
    const validate: ValidateFunction<Update>;
}

/**
 * This type is a subset of AJV's ValidateFunction, it exists to make
 * .d.ts bundles smaller and to not expose all of AJV context to the
 * world.
 * @public
 */
export declare interface ValidateFunction<T = unknown> {
    (this: any, data: any, dataCxt?: any): data is T;
    errors?: null | ErrorObject[];
}

/**
 * Validates a type with a schema in a functional way.
 * @public
 */
export declare function validateType<T>(theType: Pick<AbstractTypedSchema<T>, 'validate'>, value: T): boolean;

/**
 * World Range
 * @alpha
 */
export declare type ValidWorldRange = {
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
};

/** @alpha */
export declare type Wearable = {
    id: string;
    descriptions: I18N[];
    collectionAddress: string;
    rarity: Rarity;
    names: I18N[];
    data: {
        replaces: WearableCategory[];
        hides: WearableCategory[];
        tags: string[];
        representations: WearableRepresentation[];
        category: WearableCategory;
    };
    thumbnail: string;
    image: string;
    metrics?: Metrics;
};

/** @alpha */
export declare namespace Wearable {
    const schema: JSONSchema<Wearable>;
    const validate: ValidateFunction<Wearable>;
}

/** @alpha */
export declare enum WearableBodyShape {
    MALE = "urn:decentraland:off-chain:base-avatars:BaseMale",
    FEMALE = "urn:decentraland:off-chain:base-avatars:BaseFemale"
}

/** @alpha */
export declare namespace WearableBodyShape {
    const schema: JSONSchema<WearableBodyShape>;
    const validate: ValidateFunction<WearableBodyShape>;
}

export declare enum WearableCategory {
    EYEBROWS = "eyebrows",
    EYES = "eyes",
    FACIAL_HAIR = "facial_hair",
    HAIR = "hair",
    MOUTH = "mouth",
    UPPER_BODY = "upper_body",
    LOWER_BODY = "lower_body",
    FEET = "feet",
    EARRING = "earring",
    EYEWEAR = "eyewear",
    HAT = "hat",
    HELMET = "helmet",
    MASK = "mask",
    TIARA = "tiara",
    TOP_HEAD = "top_head"
}

export declare namespace WearableCategory {
    const schema: JSONSchema<WearableCategory>;
    const validate: ValidateFunction<WearableCategory>;
}

export declare enum WearableGender {
    MALE = "male",
    FEMALE = "female"
}

export declare namespace WearableGender {
    const schema: JSONSchema<WearableGender>;
    const validate: ValidateFunction<WearableGender>;
}

/**
 * @alpha
 */
export declare type WearableId = string;

/** @alpha */
export declare type WearableRepresentation = {
    bodyShapes: WearableBodyShape[];
    mainFile: string;
    contents: string[];
    overrideHides: WearableCategory[];
    overrideReplaces: WearableCategory[];
};

/** @alpha */
export declare namespace WearableRepresentation {
    const schema: JSONSchema<WearableRepresentation>;
    const validate: ValidateFunction<WearableRepresentation>;
}

/**
 * World
 * @alpha
 */
export declare type World = {
    validWorldRanges: Array<ValidWorldRange>;
};

/**
 * @alpha
 */
export declare namespace World {
    const schema: JSONSchema<World>;
    const validate: ValidateFunction<World>;
}

export { }
