"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetSchema = void 0;
var ChangeTree_1 = require("../changes/ChangeTree");
var spec_1 = require("../spec");
var Schema_1 = require("../Schema");
var SetSchema = /** @class */ (function () {
    function SetSchema(initialValues) {
        var _this = this;
        this.$changes = new ChangeTree_1.ChangeTree(this);
        this.$items = new Map();
        this.$indexes = new Map();
        this.$refId = 0;
        if (initialValues) {
            initialValues.forEach(function (v) { return _this.add(v); });
        }
    }
    SetSchema.is = function (type) {
        return type['set'] !== undefined;
    };
    SetSchema.prototype.add = function (value) {
        var _a, _b;
        // immediatelly return false if value already added.
        if (this.has(value)) {
            return false;
        }
        // set "index" for reference.
        var index = this.$refId++;
        if ((value['$changes']) !== undefined) {
            value['$changes'].setParent(this, this.$changes.root, index);
        }
        var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : spec_1.OPERATION.ADD;
        this.$changes.indexes[index] = index;
        this.$indexes.set(index, index);
        this.$items.set(index, value);
        this.$changes.change(index, operation);
        return index;
    };
    SetSchema.prototype.entries = function () {
        return this.$items.entries();
    };
    SetSchema.prototype.delete = function (item) {
        var entries = this.$items.entries();
        var index;
        var entry;
        while (entry = entries.next()) {
            if (entry.done) {
                break;
            }
            if (item === entry.value[1]) {
                index = entry.value[0];
                break;
            }
        }
        if (index === undefined) {
            return false;
        }
        this.$changes.delete(index);
        this.$indexes.delete(index);
        return this.$items.delete(index);
    };
    SetSchema.prototype.clear = function (isDecoding) {
        var _this = this;
        // discard previous operations.
        this.$changes.discard(true, true);
        this.$changes.indexes = {};
        // clear previous indexes
        this.$indexes.clear();
        // flag child items for garbage collection.
        if (isDecoding && typeof (this.$changes.getType()) !== "string") {
            this.$items.forEach(function (item) {
                _this.$changes.root.removeRef(item['$changes'].refId);
            });
        }
        // clear items
        this.$items.clear();
        this.$changes.operation({ index: 0, op: spec_1.OPERATION.CLEAR });
        // touch all structures until reach root
        this.$changes.touchParents();
    };
    SetSchema.prototype.has = function (value) {
        var values = this.$items.values();
        var has = false;
        var entry;
        while (entry = values.next()) {
            if (entry.done) {
                break;
            }
            if (value === entry.value) {
                has = true;
                break;
            }
        }
        return has;
    };
    SetSchema.prototype.forEach = function (callbackfn) {
        var _this = this;
        this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });
    };
    SetSchema.prototype.values = function () {
        return this.$items.values();
    };
    Object.defineProperty(SetSchema.prototype, "size", {
        get: function () {
            return this.$items.size;
        },
        enumerable: false,
        configurable: true
    });
    SetSchema.prototype.setIndex = function (index, key) {
        this.$indexes.set(index, key);
    };
    SetSchema.prototype.getIndex = function (index) {
        return this.$indexes.get(index);
    };
    SetSchema.prototype.getByIndex = function (index) {
        return this.$items.get(this.$indexes.get(index));
    };
    SetSchema.prototype.deleteByIndex = function (index) {
        var key = this.$indexes.get(index);
        this.$items.delete(key);
        this.$indexes.delete(index);
    };
    SetSchema.prototype.toArray = function () {
        return Array.from(this.$items.values());
    };
    SetSchema.prototype.toJSON = function () {
        var values = [];
        this.forEach(function (value, key) {
            values.push((typeof (value['toJSON']) === "function")
                ? value['toJSON']()
                : value);
        });
        return values;
    };
    //
    // Decoding utilities
    //
    SetSchema.prototype.clone = function (isDecoding) {
        var cloned;
        if (isDecoding) {
            // client-side
            cloned = Object.assign(new SetSchema(), this);
        }
        else {
            // server-side
            cloned = new SetSchema();
            this.forEach(function (value) {
                if (value['$changes']) {
                    cloned.add(value['clone']());
                }
                else {
                    cloned.add(value);
                }
            });
        }
        return cloned;
    };
    SetSchema.prototype.triggerAll = function () {
        Schema_1.Schema.prototype.triggerAll.apply(this);
    };
    return SetSchema;
}());
exports.SetSchema = SetSchema;
//# sourceMappingURL=SetSchema.js.map