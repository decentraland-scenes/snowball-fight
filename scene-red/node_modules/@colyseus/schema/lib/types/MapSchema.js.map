{"version":3,"file":"MapSchema.js","sourceRoot":"","sources":["../../src/types/MapSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeTree } from \"../changes/ChangeTree\";\nimport { OPERATION } from \"../spec\";\nimport { SchemaDecoderCallbacks, Schema } from \"../Schema\";\n\nexport function getMapProxy(value: MapSchema) {\n    value['$proxy'] = true;\n\n    value = new Proxy(value, {\n        get: (obj, prop) => {\n            if (\n                typeof (prop) !== \"symbol\" && // accessing properties\n                typeof (obj[prop]) === \"undefined\"\n            ) {\n                return obj.get(prop as string);\n\n            } else {\n                return obj[prop];\n            }\n        },\n\n        set: (obj, prop, setValue) => {\n            if (\n                typeof (prop) !== \"symbol\" &&\n                (\n                    (prop as string).indexOf(\"$\") === -1 &&\n                    prop !== \"onAdd\" &&\n                    prop !== \"onRemove\" &&\n                    prop !== \"onChange\"\n                )\n            ) {\n                obj.set(prop as string, setValue);\n\n            } else {\n                obj[prop] = setValue;\n            }\n            return true;\n        },\n\n        deleteProperty: (obj, prop) => {\n            obj.delete(prop as string);\n            return true;\n        },\n    });\n\n    return value;\n}\n\nexport class MapSchema<V=any> implements Map<string, V>, SchemaDecoderCallbacks {\n    protected $changes: ChangeTree = new ChangeTree(this);\n\n    protected $items: Map<string, V> = new Map<string, V>();\n    protected $indexes: Map<number, string> = new Map<number, string>();\n\n    protected $refId: number = 0;\n\n    //\n    // Decoding callbacks\n    //\n    public onAdd?: (item: V, key: string) => void;\n    public onRemove?: (item: V, key: string) => void;\n    public onChange?: (item: V, key: string) => void;\n\n    static is(type: any) {\n        return type['map'] !== undefined;\n    }\n\n    constructor (initialValues?: Map<string, V> | any) {\n        if (initialValues) {\n            if (initialValues instanceof Map) {\n                initialValues.forEach((v, k) => this.set(k, v));\n\n            } else {\n                for (const k in initialValues) {\n                    this.set(k, initialValues[k]);\n                }\n            }\n        }\n    }\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<[string, V]> { return this.$items[Symbol.iterator](); }\n    get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag] }\n\n    set(key: string, value: V) {\n        if (value === undefined || value === null) {\n            throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);\n        }\n\n        // get \"index\" for this value.\n        const hasIndex = typeof(this.$changes.indexes[key]) !== \"undefined\";\n        const index = (hasIndex)\n            ? this.$changes.indexes[key]\n            : this.$refId++;\n\n        let operation: OPERATION = (hasIndex)\n            ? OPERATION.REPLACE\n            : OPERATION.ADD;\n\n        const isRef = (value['$changes']) !== undefined;\n        if (isRef) {\n            (value['$changes'] as ChangeTree).setParent(\n                this,\n                this.$changes.root,\n                index\n            );\n        }\n\n        //\n        // (encoding)\n        // set a unique id to relate directly with this key/value.\n        //\n        if (!hasIndex) {\n            this.$changes.indexes[key] = index;\n            this.$indexes.set(index, key);\n\n        } else if (\n            isRef && // if is schema, force ADD operation if value differ from previous one.\n            this.$items.get(key) !== value\n        ) {\n            operation = OPERATION.ADD;\n        }\n\n        this.$items.set(key, value);\n\n        this.$changes.change(key, operation);\n\n        return this;\n    }\n\n    get(key: string): V | undefined {\n        return this.$items.get(key);\n    }\n\n    delete(key: string) {\n        //\n        // TODO: add a \"purge\" method after .encode() runs, to cleanup removed `$indexes`\n        //\n        // We don't remove $indexes to allow setting the same key in the same patch\n        // (See \"should allow to remove and set an item in the same place\" test)\n        //\n        // // const index = this.$changes.indexes[key];\n        // // this.$indexes.delete(index);\n\n        this.$changes.delete(key);\n        return this.$items.delete(key);\n    }\n\n    clear(isDecoding?: boolean) {\n        // discard previous operations.\n        this.$changes.discard(true, true);\n        this.$changes.indexes = {};\n\n        // clear previous indexes\n        this.$indexes.clear();\n\n        // flag child items for garbage collection.\n        if (isDecoding && typeof (this.$changes.getType()) !== \"string\") {\n            this.$items.forEach((item: V) => {\n                this.$changes.root.removeRef(item['$changes'].refId);\n            });\n        }\n\n        // clear items\n        this.$items.clear();\n\n        this.$changes.operation({ index: 0, op: OPERATION.CLEAR });\n\n        // touch all structures until reach root\n        this.$changes.touchParents();\n    }\n\n    has (key: string) {\n        return this.$items.has(key);\n    }\n\n    forEach(callbackfn: (value: V, key: string, map: Map<string, V>) => void) {\n        this.$items.forEach(callbackfn);\n    }\n\n    entries () {\n        return this.$items.entries();\n    }\n\n    keys () {\n        return this.$items.keys();\n    }\n\n    values() {\n        return this.$items.values();\n    }\n\n    get size () {\n        return this.$items.size;\n    }\n\n    protected setIndex(index: number, key: string) {\n        this.$indexes.set(index, key);\n    }\n\n    protected getIndex(index: number) {\n        return this.$indexes.get(index);\n    }\n\n    protected getByIndex(index: number) {\n        return this.$items.get(this.$indexes.get(index));\n    }\n\n    protected deleteByIndex(index: number) {\n        const key = this.$indexes.get(index);\n        this.$items.delete(key);\n        this.$indexes.delete(index);\n    }\n\n    toJSON() {\n        const map: any = {};\n\n        this.forEach((value, key) => {\n            map[key] = (typeof (value['toJSON']) === \"function\")\n                ? value['toJSON']()\n                : value;\n        });\n\n        return map;\n    }\n\n    //\n    // Decoding utilities\n    //\n    clone(isDecoding?: boolean): MapSchema<V> {\n        let cloned: MapSchema;\n\n        if (isDecoding) {\n            // client-side\n            cloned = Object.assign(new MapSchema(), this);\n\n        } else {\n            // server-side\n            cloned = new MapSchema();\n            this.forEach((value, key) => {\n                if (value['$changes']) {\n                    cloned.set(key, value['clone']());\n                } else {\n                    cloned.set(key, value);\n                }\n            })\n        }\n\n        return cloned;\n    }\n\n    triggerAll (): void {\n        Schema.prototype.triggerAll.apply(this);\n    }\n}\n"]}