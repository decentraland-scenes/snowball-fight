{"version":3,"file":"ChangeTree.js","sourceRoot":"","sources":["../../src/changes/ChangeTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { OPERATION } from \"../spec\";\nimport { Schema } from \"../Schema\";\nimport { SchemaDefinition, FilterChildrenCallback } from \"../annotations\";\n\nimport { MapSchema } from \"../types/MapSchema\";\nimport { ArraySchema } from \"../types/ArraySchema\";\nimport { CollectionSchema } from \"../types/CollectionSchema\";\nimport { SetSchema } from \"../types/SetSchema\";\n\nexport type Ref = Schema\n    | ArraySchema\n    | MapSchema\n    | CollectionSchema\n    | SetSchema;\n\nexport interface ChangeOperation {\n    op: OPERATION,\n    index: number,\n}\n\n//\n// FieldCache is used for @filter()\n//\nexport interface FieldCache {\n    beginIndex: number;\n    endIndex: number;\n}\n\n\n//\n// Root holds all schema references by unique id\n//\nexport class Root {\n    //\n    // Relation of refId => Schema structure\n    // For direct access of structures during decoding time.\n    //\n    public refs = new Map<number, Ref>();\n    public refCounts: {[refId: number]: number} = {};\n    public deletedRefs = new Set<number>();\n\n    protected nextUniqueId: number = 0;\n\n    getNextUniqueId() {\n        return this.nextUniqueId++;\n    }\n\n    // for decoding\n    addRef(refId: number, ref: Ref, incrementCount: boolean = true) {\n        this.refs.set(refId, ref);\n\n        if (incrementCount) {\n            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n        }\n    }\n\n    // for decoding\n    removeRef(refId) {\n        this.refCounts[refId] = this.refCounts[refId] - 1;\n        this.deletedRefs.add(refId);\n    }\n\n    clearRefs() {\n        this.refs.clear();\n        this.deletedRefs.clear();\n        this.refCounts = {};\n    }\n\n    // for decoding\n    garbageCollectDeletedRefs() {\n        this.deletedRefs.forEach((refId) => {\n            if (this.refCounts[refId] <= 0) {\n                const ref = this.refs.get(refId);\n\n                //\n                // Ensure child schema instances have their references removed as well.\n                //\n                if (ref instanceof Schema) {\n                    for (const fieldName in ref['_definition'].schema) {\n                        if (\n                            typeof (ref['_definition'].schema[fieldName]) !== \"string\" &&\n                            ref[fieldName] &&\n                            ref[fieldName]['$changes']\n                        ) {\n                            this.removeRef(ref[fieldName]['$changes'].refId);\n                        }\n                    }\n\n                } else {\n                    const definition: SchemaDefinition = ref['$changes'].parent._definition;\n                    const type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];\n\n                    if (typeof (Object.values(type)[0]) === \"function\") {\n                        Array.from(ref.values())\n                            .forEach((child) => this.removeRef(child['$changes'].refId));\n                    }\n                }\n\n                this.refs.delete(refId);\n                delete this.refCounts[refId];\n            }\n        });\n\n        // clear deleted refs.\n        this.deletedRefs.clear();\n    }\n}\n\nexport class ChangeTree {\n    ref: Ref;\n    refId: number;\n\n    root?: Root;\n\n    parent?: Ref;\n    parentIndex?: number;\n\n    indexes: {[index: string]: any};\n\n    changed: boolean = false;\n    changes = new Map<number, ChangeOperation>();\n    allChanges = new Set<number>();\n\n    // cached indexes for filtering\n    caches: {[field: number]: number[]} = {};\n\n    currentCustomOperation: number = 0;\n\n    constructor(ref: Ref, parent?: Ref, root?: Root) {\n        this.ref = ref;\n        this.setParent(parent, root);\n    }\n\n    setParent(\n        parent: Ref,\n        root?: Root,\n        parentIndex?: number,\n    ) {\n        if (!this.indexes) {\n            this.indexes = (this.ref instanceof Schema)\n                ? this.ref['_definition'].indexes\n                : {};\n        }\n\n        this.parent = parent;\n        this.parentIndex = parentIndex;\n\n        // avoid setting parents with empty `root`\n        if (!root) { return; }\n        this.root = root;\n\n        //\n        // assign same parent on child structures\n        //\n        if (this.ref instanceof Schema) {\n            const definition: SchemaDefinition = this.ref['_definition'];\n\n            for (let field in definition.schema) {\n                const value = this.ref[field];\n\n                if (value && value['$changes']) {\n                    const parentIndex = definition.indexes[field];\n\n                    (value['$changes'] as ChangeTree).setParent(\n                        this.ref,\n                        root,\n                        parentIndex,\n                    );\n                }\n            }\n\n        } else if (typeof (this.ref) === \"object\") {\n            this.ref.forEach((value, key) => {\n                if (value instanceof Schema) {\n                    const changeTreee = value['$changes'];\n                    const parentIndex = this.ref['$changes'].indexes[key];\n\n                    changeTreee.setParent(\n                        this.ref,\n                        this.root,\n                        parentIndex,\n                    );\n                }\n            });\n        }\n    }\n\n    operation(op: ChangeOperation) {\n        this.changes.set(--this.currentCustomOperation, op);\n    }\n\n    change(fieldName: string | number, operation: OPERATION = OPERATION.ADD) {\n        const index = (typeof (fieldName) === \"number\")\n            ? fieldName\n            : this.indexes[fieldName];\n\n        this.assertValidIndex(index, fieldName);\n\n        const previousChange = this.changes.get(index);\n\n        if (\n            !previousChange ||\n            previousChange.op === OPERATION.DELETE ||\n            previousChange.op === OPERATION.TOUCH // (mazmorra.io's BattleAction issue)\n        ) {\n            this.changes.set(index, {\n                op: (!previousChange)\n                    ? operation\n                    : (previousChange.op === OPERATION.DELETE)\n                        ? OPERATION.DELETE_AND_ADD\n                        : operation,\n                        // : OPERATION.REPLACE,\n                index\n            });\n        }\n\n        this.allChanges.add(index);\n\n        this.changed = true;\n        this.touchParents();\n    }\n\n    touch(fieldName: string | number) {\n        const index = (typeof (fieldName) === \"number\")\n            ? fieldName\n            : this.indexes[fieldName];\n\n        this.assertValidIndex(index, fieldName);\n\n        if (!this.changes.has(index)) {\n            this.changes.set(index, { op: OPERATION.TOUCH, index });\n        }\n\n        this.allChanges.add(index);\n\n        // ensure touch is placed until the $root is found.\n        this.touchParents();\n    }\n\n    touchParents() {\n        if (this.parent) {\n            (this.parent['$changes'] as ChangeTree).touch(this.parentIndex);\n        }\n    }\n\n    getType(index?: number) {\n        if (this.ref['_definition']) {\n            const definition = (this.ref as Schema)['_definition'];\n            return definition.schema[ definition.fieldsByIndex[index] ];\n\n        } else {\n            const definition = (this.parent as Schema)['_definition'];\n            const parentType = definition.schema[ definition.fieldsByIndex[this.parentIndex] ];\n\n            //\n            // Get the child type from parent structure.\n            // - [\"string\"] => \"string\"\n            // - { map: \"string\" } => \"string\"\n            // - { set: \"string\" } => \"string\"\n            //\n            return Object.values(parentType)[0];\n        }\n    }\n\n    getChildrenFilter(): FilterChildrenCallback {\n        const childFilters = (this.parent as Schema)['_definition'].childFilters;\n        return childFilters && childFilters[this.parentIndex];\n    }\n\n    //\n    // used during `.encode()`\n    //\n    getValue(index: number) {\n        return this.ref['getByIndex'](index);\n    }\n\n    delete(fieldName: string | number) {\n        const index = (typeof (fieldName) === \"number\")\n            ? fieldName\n            : this.indexes[fieldName];\n\n        if (index === undefined) {\n            console.warn(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index: ${fieldName} (${index})`);\n            return;\n        }\n\n        const previousValue = this.getValue(index);\n        // console.log(\"$changes.delete =>\", { fieldName, index, previousValue });\n\n        this.changes.set(index, { op: OPERATION.DELETE, index });\n\n        this.allChanges.delete(index);\n\n        // delete cache\n        delete this.caches[index];\n\n        // remove `root` reference\n        if (previousValue && previousValue['$changes']) {\n            previousValue['$changes'].parent = undefined;\n        }\n\n        this.changed = true;\n        this.touchParents();\n    }\n\n    discard(changed: boolean = false, discardAll: boolean = false) {\n        //\n        // Map, Array, etc:\n        // Remove cached key to ensure ADD operations is unsed instead of\n        // REPLACE in case same key is used on next patches.\n        //\n        // TODO: refactor this. this is not relevant for Collection and Set.\n        //\n        if (!(this.ref instanceof Schema)) {\n            this.changes.forEach((change) => {\n                if (change.op === OPERATION.DELETE) {\n                    const index = this.ref['getIndex'](change.index)\n                    delete this.indexes[index];\n                }\n            });\n        }\n\n        this.changes.clear();\n        this.changed = changed;\n\n        if (discardAll) {\n            this.allChanges.clear();\n        }\n\n        // re-set `currentCustomOperation`\n        this.currentCustomOperation = 0;\n    }\n\n    /**\n     * Recursively discard all changes from this, and child structures.\n     */\n    discardAll() {\n        this.changes.forEach((change) => {\n            const value = this.getValue(change.index);\n\n            if (value && value['$changes']) {\n                value['$changes'].discardAll();\n            }\n        });\n\n        this.discard();\n    }\n\n    // cache(field: number, beginIndex: number, endIndex: number) {\n    cache(field: number, cachedBytes: number[]) {\n        this.caches[field] = cachedBytes;\n    }\n\n    clone() {\n        return new ChangeTree(this.ref, this.parent, this.root);\n    }\n\n    ensureRefId() {\n        // skip if refId is already set.\n        if (this.refId !== undefined) {\n            return;\n        }\n\n        this.refId = this.root.getNextUniqueId();\n    }\n\n    protected assertValidIndex(index: number, fieldName: string | number) {\n        if (index === undefined) {\n            throw new Error(`ChangeTree: missing index for field \"${fieldName}\"`);\n        }\n    }\n\n}\n"]}