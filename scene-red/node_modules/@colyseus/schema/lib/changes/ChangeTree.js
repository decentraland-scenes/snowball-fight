"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeTree = exports.Root = void 0;
var spec_1 = require("../spec");
var Schema_1 = require("../Schema");
//
// Root holds all schema references by unique id
//
var Root = /** @class */ (function () {
    function Root() {
        //
        // Relation of refId => Schema structure
        // For direct access of structures during decoding time.
        //
        this.refs = new Map();
        this.refCounts = {};
        this.deletedRefs = new Set();
        this.nextUniqueId = 0;
    }
    Root.prototype.getNextUniqueId = function () {
        return this.nextUniqueId++;
    };
    // for decoding
    Root.prototype.addRef = function (refId, ref, incrementCount) {
        if (incrementCount === void 0) { incrementCount = true; }
        this.refs.set(refId, ref);
        if (incrementCount) {
            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;
        }
    };
    // for decoding
    Root.prototype.removeRef = function (refId) {
        this.refCounts[refId] = this.refCounts[refId] - 1;
        this.deletedRefs.add(refId);
    };
    Root.prototype.clearRefs = function () {
        this.refs.clear();
        this.deletedRefs.clear();
        this.refCounts = {};
    };
    // for decoding
    Root.prototype.garbageCollectDeletedRefs = function () {
        var _this = this;
        this.deletedRefs.forEach(function (refId) {
            if (_this.refCounts[refId] <= 0) {
                var ref = _this.refs.get(refId);
                //
                // Ensure child schema instances have their references removed as well.
                //
                if (ref instanceof Schema_1.Schema) {
                    for (var fieldName in ref['_definition'].schema) {
                        if (typeof (ref['_definition'].schema[fieldName]) !== "string" &&
                            ref[fieldName] &&
                            ref[fieldName]['$changes']) {
                            _this.removeRef(ref[fieldName]['$changes'].refId);
                        }
                    }
                }
                else {
                    var definition = ref['$changes'].parent._definition;
                    var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];
                    if (typeof (Object.values(type)[0]) === "function") {
                        Array.from(ref.values())
                            .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });
                    }
                }
                _this.refs.delete(refId);
                delete _this.refCounts[refId];
            }
        });
        // clear deleted refs.
        this.deletedRefs.clear();
    };
    return Root;
}());
exports.Root = Root;
var ChangeTree = /** @class */ (function () {
    function ChangeTree(ref, parent, root) {
        this.changed = false;
        this.changes = new Map();
        this.allChanges = new Set();
        // cached indexes for filtering
        this.caches = {};
        this.currentCustomOperation = 0;
        this.ref = ref;
        this.setParent(parent, root);
    }
    ChangeTree.prototype.setParent = function (parent, root, parentIndex) {
        var _this = this;
        if (!this.indexes) {
            this.indexes = (this.ref instanceof Schema_1.Schema)
                ? this.ref['_definition'].indexes
                : {};
        }
        this.parent = parent;
        this.parentIndex = parentIndex;
        // avoid setting parents with empty `root`
        if (!root) {
            return;
        }
        this.root = root;
        //
        // assign same parent on child structures
        //
        if (this.ref instanceof Schema_1.Schema) {
            var definition = this.ref['_definition'];
            for (var field in definition.schema) {
                var value = this.ref[field];
                if (value && value['$changes']) {
                    var parentIndex_1 = definition.indexes[field];
                    value['$changes'].setParent(this.ref, root, parentIndex_1);
                }
            }
        }
        else if (typeof (this.ref) === "object") {
            this.ref.forEach(function (value, key) {
                if (value instanceof Schema_1.Schema) {
                    var changeTreee = value['$changes'];
                    var parentIndex_2 = _this.ref['$changes'].indexes[key];
                    changeTreee.setParent(_this.ref, _this.root, parentIndex_2);
                }
            });
        }
    };
    ChangeTree.prototype.operation = function (op) {
        this.changes.set(--this.currentCustomOperation, op);
    };
    ChangeTree.prototype.change = function (fieldName, operation) {
        if (operation === void 0) { operation = spec_1.OPERATION.ADD; }
        var index = (typeof (fieldName) === "number")
            ? fieldName
            : this.indexes[fieldName];
        this.assertValidIndex(index, fieldName);
        var previousChange = this.changes.get(index);
        if (!previousChange ||
            previousChange.op === spec_1.OPERATION.DELETE ||
            previousChange.op === spec_1.OPERATION.TOUCH // (mazmorra.io's BattleAction issue)
        ) {
            this.changes.set(index, {
                op: (!previousChange)
                    ? operation
                    : (previousChange.op === spec_1.OPERATION.DELETE)
                        ? spec_1.OPERATION.DELETE_AND_ADD
                        : operation,
                // : OPERATION.REPLACE,
                index: index
            });
        }
        this.allChanges.add(index);
        this.changed = true;
        this.touchParents();
    };
    ChangeTree.prototype.touch = function (fieldName) {
        var index = (typeof (fieldName) === "number")
            ? fieldName
            : this.indexes[fieldName];
        this.assertValidIndex(index, fieldName);
        if (!this.changes.has(index)) {
            this.changes.set(index, { op: spec_1.OPERATION.TOUCH, index: index });
        }
        this.allChanges.add(index);
        // ensure touch is placed until the $root is found.
        this.touchParents();
    };
    ChangeTree.prototype.touchParents = function () {
        if (this.parent) {
            this.parent['$changes'].touch(this.parentIndex);
        }
    };
    ChangeTree.prototype.getType = function (index) {
        if (this.ref['_definition']) {
            var definition = this.ref['_definition'];
            return definition.schema[definition.fieldsByIndex[index]];
        }
        else {
            var definition = this.parent['_definition'];
            var parentType = definition.schema[definition.fieldsByIndex[this.parentIndex]];
            //
            // Get the child type from parent structure.
            // - ["string"] => "string"
            // - { map: "string" } => "string"
            // - { set: "string" } => "string"
            //
            return Object.values(parentType)[0];
        }
    };
    ChangeTree.prototype.getChildrenFilter = function () {
        var childFilters = this.parent['_definition'].childFilters;
        return childFilters && childFilters[this.parentIndex];
    };
    //
    // used during `.encode()`
    //
    ChangeTree.prototype.getValue = function (index) {
        return this.ref['getByIndex'](index);
    };
    ChangeTree.prototype.delete = function (fieldName) {
        var index = (typeof (fieldName) === "number")
            ? fieldName
            : this.indexes[fieldName];
        if (index === undefined) {
            console.warn("@colyseus/schema " + this.ref.constructor.name + ": trying to delete non-existing index: " + fieldName + " (" + index + ")");
            return;
        }
        var previousValue = this.getValue(index);
        // console.log("$changes.delete =>", { fieldName, index, previousValue });
        this.changes.set(index, { op: spec_1.OPERATION.DELETE, index: index });
        this.allChanges.delete(index);
        // delete cache
        delete this.caches[index];
        // remove `root` reference
        if (previousValue && previousValue['$changes']) {
            previousValue['$changes'].parent = undefined;
        }
        this.changed = true;
        this.touchParents();
    };
    ChangeTree.prototype.discard = function (changed, discardAll) {
        var _this = this;
        if (changed === void 0) { changed = false; }
        if (discardAll === void 0) { discardAll = false; }
        //
        // Map, Array, etc:
        // Remove cached key to ensure ADD operations is unsed instead of
        // REPLACE in case same key is used on next patches.
        //
        // TODO: refactor this. this is not relevant for Collection and Set.
        //
        if (!(this.ref instanceof Schema_1.Schema)) {
            this.changes.forEach(function (change) {
                if (change.op === spec_1.OPERATION.DELETE) {
                    var index = _this.ref['getIndex'](change.index);
                    delete _this.indexes[index];
                }
            });
        }
        this.changes.clear();
        this.changed = changed;
        if (discardAll) {
            this.allChanges.clear();
        }
        // re-set `currentCustomOperation`
        this.currentCustomOperation = 0;
    };
    /**
     * Recursively discard all changes from this, and child structures.
     */
    ChangeTree.prototype.discardAll = function () {
        var _this = this;
        this.changes.forEach(function (change) {
            var value = _this.getValue(change.index);
            if (value && value['$changes']) {
                value['$changes'].discardAll();
            }
        });
        this.discard();
    };
    // cache(field: number, beginIndex: number, endIndex: number) {
    ChangeTree.prototype.cache = function (field, cachedBytes) {
        this.caches[field] = cachedBytes;
    };
    ChangeTree.prototype.clone = function () {
        return new ChangeTree(this.ref, this.parent, this.root);
    };
    ChangeTree.prototype.ensureRefId = function () {
        // skip if refId is already set.
        if (this.refId !== undefined) {
            return;
        }
        this.refId = this.root.getNextUniqueId();
    };
    ChangeTree.prototype.assertValidIndex = function (index, fieldName) {
        if (index === undefined) {
            throw new Error("ChangeTree: missing index for field \"" + fieldName + "\"");
        }
    };
    return ChangeTree;
}());
exports.ChangeTree = ChangeTree;
//# sourceMappingURL=ChangeTree.js.map