{"version":3,"file":"Schema.js","sourceRoot":"","sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { SWITCH_TO_STRUCTURE, TYPE_ID, OPERATION } from './spec';\nimport { ClientWithSessionId, PrimitiveType, Context, SchemaDefinition, DefinitionType } from \"./annotations\";\n\nimport * as encode from \"./encoding/encode\";\nimport * as decode from \"./encoding/decode\";\nimport type { Iterator } from \"./encoding/decode\"; // dts-bundle-generator\n\nimport { ArraySchema } from \"./types/ArraySchema\";\nimport { MapSchema } from \"./types/MapSchema\";\nimport { CollectionSchema } from './types/CollectionSchema';\nimport { SetSchema } from './types/SetSchema';\n\nimport { ChangeTree, Root, Ref, ChangeOperation } from \"./changes/ChangeTree\";\nimport { NonFunctionPropNames } from './types/HelperTypes';\nimport { EventEmitter_ } from './events/EventEmitter';\nimport { ClientState } from './filters';\nimport { getType } from './types';\n\nexport interface DataChange<T=any> {\n    op: OPERATION,\n    field: string;\n    dynamicIndex?: number | string;\n    value: T;\n    previousValue: T;\n}\n\nexport interface SchemaDecoderCallbacks {\n    onAdd?: (item: any, key: any) => void;\n    onRemove?: (item: any, key: any) => void;\n    onChange?: (item: any, key: any) => void;\n    clone(decoding?: boolean): SchemaDecoderCallbacks;\n    clear(decoding?: boolean);\n    decode?(byte, it: Iterator);\n}\n\nclass EncodeSchemaError extends Error {}\n\nfunction assertType(value: any, type: string, klass: Schema, field: string | number) {\n    let typeofTarget: string;\n    let allowNull: boolean = false;\n\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\n            }\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n    }\n\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction assertInstanceType(\n    value: Schema,\n    type: typeof Schema\n        | typeof ArraySchema\n        | typeof MapSchema\n        | typeof CollectionSchema\n        | typeof SetSchema,\n    klass: Schema,\n    field: string | number,\n) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${(value as any).constructor.name}' was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction encodePrimitiveType(\n    type: PrimitiveType,\n    bytes: number[],\n    value: any,\n    klass: Schema,\n    field: string | number,\n) {\n    assertType(value, type as string, klass, field);\n\n    const encodeFunc = encode[type as string];\n\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n\n    } else {\n        throw new EncodeSchemaError(`a '${type}' was expected, but ${value} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction decodePrimitiveType (type: string, bytes: number[], it: Iterator) {\n    return decode[type as string](bytes, it);\n}\n\n/**\n * Schema encoder / decoder\n */\nexport abstract class Schema {\n    static _typeid: number;\n    static _context: Context;\n\n    static _definition: SchemaDefinition = SchemaDefinition.create();\n\n    static onError(e) {\n        console.error(e);\n    }\n\n    static is(type: DefinitionType) {\n        return (\n            type['_definition'] &&\n            type['_definition'].schema !== undefined\n        );\n    }\n\n    protected $changes: ChangeTree;\n    // protected $root: ChangeSet;\n\n    // TODO: refactor. this feature needs to be ported to other languages with potentially different API\n    protected $listeners: { [field: string]: EventEmitter_<(a: any, b: any) => void> };\n\n    public onChange?(changes: DataChange[]);\n    public onRemove?();\n\n    // allow inherited classes to have a constructor\n    constructor(...args: any[]) {\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: {\n                value: new ChangeTree(this, undefined, new Root()),\n                enumerable: false,\n                writable: true\n            },\n\n            $listeners: {\n                value: {},\n                enumerable: false,\n                writable: true\n            },\n        });\n\n        const descriptors = this._definition.descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n\n        //\n        // Assign initial values\n        //\n        if (args[0]) {\n            this.assign(args[0]);\n        }\n    }\n\n    public assign(\n        props: { [prop in NonFunctionPropNames<this>]?: this[prop] }\n    ) {\n        Object.assign(this, props);\n        return this;\n    }\n\n    protected get _definition () { return (this.constructor as typeof Schema)._definition; }\n\n    public listen <K extends NonFunctionPropNames<this>>(attr: K, callback: (value: this[K], previousValue: this[K]) => void) {\n        if (!this.$listeners[attr as string]) {\n            this.$listeners[attr as string] = new EventEmitter_();\n        }\n        this.$listeners[attr as string].register(callback);\n\n        // return un-register callback.\n        return () =>\n            this.$listeners[attr as string].remove(callback);\n    }\n\n    decode(\n        bytes: number[],\n        it: Iterator = { offset: 0 },\n        ref: Ref = this,\n        allChanges: Map<number, DataChange[]> = new Map<number, DataChange[]>(),\n    ) {\n        const $root = this.$changes.root;\n        const totalBytes = bytes.length;\n\n        let refId: number = 0;\n        let changes: DataChange[] = [];\n\n        $root.refs.set(refId, this);\n        allChanges.set(refId, changes);\n\n        while (it.offset < totalBytes) {\n            let byte = bytes[it.offset++];\n\n            if (byte == SWITCH_TO_STRUCTURE) {\n                refId = decode.number(bytes, it);\n\n                const nextRef = $root.refs.get(refId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${refId}`); }\n\n                ref = nextRef;\n\n                // create empty list of changes for this refId.\n                changes = [];\n                allChanges.set(refId, changes);\n\n                continue;\n            }\n\n            const changeTree: ChangeTree = ref['$changes'];\n            const isSchema = (ref['_definition'] !== undefined);\n\n            const operation = (isSchema)\n                ? (byte >> 6) << 6 // \"compressed\" index + operation\n                : byte; // \"uncompressed\" index + operation (array/map items)\n\n            if (operation === OPERATION.CLEAR) {\n                //\n                // TODO: refactor me!\n                // The `.clear()` method is calling `$root.removeRef(refId)` for\n                // each item inside this collection\n                //\n                (ref as SchemaDecoderCallbacks).clear(true);\n                continue;\n            }\n\n            const fieldIndex = (isSchema)\n                ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                : decode.number(bytes, it);\n\n            const fieldName = (isSchema)\n                ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                : \"\";\n\n            let type = changeTree.getType(fieldIndex);\n            let value: any;\n            let previousValue: any;\n\n            let dynamicIndex: number | string;\n\n            if (!isSchema) {\n                previousValue = ref['getByIndex'](fieldIndex);\n\n                if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                    dynamicIndex = (ref instanceof MapSchema)\n                        ? decode.string(bytes, it)\n                        : fieldIndex;\n                    ref['setIndex'](fieldIndex, dynamicIndex);\n\n                } else {\n                    // here\n                    dynamicIndex = ref['getIndex'](fieldIndex);\n                }\n\n            } else {\n                previousValue = ref[`_${fieldName}`];\n            }\n\n            //\n            // Delete operations\n            //\n            if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n            {\n                if (operation !== OPERATION.DELETE_AND_ADD) {\n                    ref['deleteByIndex'](fieldIndex);\n                }\n\n                // Flag `refId` for garbage collection.\n                if (previousValue && previousValue['$changes']) {\n                    $root.removeRef(previousValue['$changes'].refId);\n                }\n\n                value = null;\n            }\n\n            if (fieldName === undefined) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (decode.switchStructureCheck(bytes, it)) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n\n                continue;\n\n            } else if (operation === OPERATION.DELETE) {\n                //\n                // FIXME: refactor me.\n                // Don't do anything.\n                //\n\n            } else if (Schema.is(type)) {\n                const refId = decode.number(bytes, it);\n                value = $root.refs.get(refId);\n\n                if (operation !== OPERATION.REPLACE) {\n                    const childType = this.getSchemaType(bytes, it, type);\n\n                    if (!value) {\n                        value = this.createTypeInstance(childType);\n                        value.$changes.refId = refId;\n\n                        if (previousValue) {\n                            value.onChange = previousValue.onChange;\n                            value.onRemove = previousValue.onRemove;\n                            value.$listeners = previousValue.$listeners;\n\n                            if (\n                                previousValue['$changes'].refId &&\n                                refId !== previousValue['$changes'].refId\n                            ) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                            }\n                        }\n                    }\n\n                    $root.addRef(refId, value, (value !== previousValue));\n                }\n            } else if (typeof(type) === \"string\") {\n                //\n                // primitive value (number, string, boolean, etc)\n                //\n                value = decodePrimitiveType(type as string, bytes, it);\n\n            } else {\n                const typeDef = getType(Object.keys(type)[0]);\n                const refId = decode.number(bytes, it);\n\n                const valueRef: SchemaDecoderCallbacks = ($root.refs.has(refId))\n                    ? previousValue || $root.refs.get(refId)\n                    : new typeDef.constructor();\n\n                value = valueRef.clone(true);\n                value.$changes.refId = refId;\n\n                // preserve schema callbacks\n                if (previousValue) {\n                    value.onAdd = previousValue.onAdd;\n                    value.onRemove = previousValue.onRemove;\n                    value.onChange = previousValue.onChange;\n\n                    if (\n                        previousValue['$changes'].refId &&\n                        refId !== previousValue['$changes'].refId\n                    ) {\n                        $root.removeRef(previousValue['$changes'].refId);\n\n                        //\n                        // Trigger onRemove if structure has been replaced.\n                        //\n                        const deletes: DataChange[] = [];\n                        const entries: IterableIterator<[any, any]> = previousValue.entries();\n                        let iter: IteratorResult<[any, any]>;\n                        while ((iter = entries.next()) && !iter.done) {\n                            const [key, value] = iter.value;\n                            deletes.push({\n                                op: OPERATION.DELETE,\n                                field: key,\n                                value: undefined,\n                                previousValue: value,\n                            });\n                        }\n\n                        allChanges.set(previousValue['$changes'].refId, deletes);\n                    }\n                }\n\n                $root.addRef(refId, value, (valueRef !== previousValue));\n\n                //\n                // TODO: deprecate proxies on next version.\n                // get proxy to target value.\n                //\n                if (typeDef.getProxy) {\n                    value = typeDef.getProxy(value);\n                }\n            }\n\n            let hasChange = (previousValue !== value);\n\n            if (\n                value !== null &&\n                value !== undefined\n            ) {\n                if (value['$changes']) {\n                    value['$changes'].setParent(\n                        changeTree.ref,\n                        changeTree.root,\n                        fieldIndex,\n                    );\n                }\n\n                if (ref instanceof Schema) {\n                    ref[fieldName] = value;\n\n                    //\n                    // FIXME: use `_field` instead of `field`.\n                    //\n                    // `field` is going to use the setter of the PropertyDescriptor\n                    // and create a proxy for array/map. This is only useful for\n                    // backwards-compatibility with @colyseus/schema@0.5.x\n                    //\n                    // // ref[_field] = value;\n\n                } else if (ref instanceof MapSchema) {\n                    // const key = ref['$indexes'].get(field);\n                    const key = dynamicIndex as string;\n\n                    // ref.set(key, value);\n                    ref['$items'].set(key, value);\n\n                } else if (ref instanceof ArraySchema) {\n                    // const key = ref['$indexes'][field];\n                    // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                    // ref[key] = value;\n                    ref.setAt(fieldIndex, value);\n\n                } else if (ref instanceof CollectionSchema) {\n                    const index = ref.add(value);\n                    ref['setIndex'](fieldIndex, index);\n\n                } else if (ref instanceof SetSchema) {\n                    const index = ref.add(value);\n                    if (index !== false) {\n                        ref['setIndex'](fieldIndex, index);\n                    }\n                }\n            }\n\n            if (\n                hasChange\n                // &&\n                // (\n                //     this.onChange || ref.$listeners[field]\n                // )\n            ) {\n                changes.push({\n                    op: operation,\n                    field: fieldName,\n                    dynamicIndex,\n                    value,\n                    previousValue,\n                });\n            }\n        }\n\n        this._triggerChanges(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    encode(\n        encodeAll = false,\n        bytes: number[] = [],\n        useFilters: boolean = false,\n    ) {\n        const rootChangeTree = this.$changes;\n        const refIdsVisited = new WeakSet<ChangeTree>();\n\n        const changeTrees: ChangeTree[] = [rootChangeTree];\n        let numChangeTrees = 1;\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n            const ref = changeTree.ref;\n            const isSchema = (ref instanceof Schema);\n\n            // Generate unique refId for the ChangeTree.\n            changeTree.ensureRefId();\n\n            // mark this ChangeTree as visited.\n            refIdsVisited.add(changeTree);\n\n            // root `refId` is skipped.\n            if (\n                changeTree !== rootChangeTree &&\n                (changeTree.changed || encodeAll)\n            ) {\n                encode.uint8(bytes, SWITCH_TO_STRUCTURE);\n                encode.number(bytes, changeTree.refId);\n            }\n\n            const changes: ChangeOperation[] | number[] = (encodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const operation: ChangeOperation = (encodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                const fieldIndex = operation.index;\n\n                const field = (isSchema)\n                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                    : fieldIndex;\n\n                // cache begin index if `useFilters`\n                const beginIndex = bytes.length;\n\n                // encode field index + operation\n                if (operation.op !== OPERATION.TOUCH) {\n                    if (isSchema) {\n                        //\n                        // Compress `fieldIndex` + `operation` into a single byte.\n                        // This adds a limitaion of 64 fields per Schema structure\n                        //\n                        encode.uint8(bytes, (fieldIndex | operation.op));\n\n                    } else {\n                        encode.uint8(bytes, operation.op);\n\n                        // custom operations\n                        if (operation.op === OPERATION.CLEAR) {\n                            continue;\n                        }\n\n                        // indexed operations\n                        encode.number(bytes, fieldIndex);\n                    }\n                }\n\n                //\n                // encode \"alias\" for dynamic fields (maps)\n                //\n                if (\n                    !isSchema &&\n                    (operation.op & OPERATION.ADD) == OPERATION.ADD // ADD or DELETE_AND_ADD\n                ) {\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(bytes, dynamicIndex);\n                    }\n                }\n\n                if (operation.op === OPERATION.DELETE) {\n                    //\n                    // TODO: delete from filter cache data.\n                    //\n                    // if (useFilters) {\n                    //     delete changeTree.caches[fieldIndex];\n                    // }\n                    continue;\n                }\n\n                // const type = changeTree.childType || ref._schema[field];\n                const type = changeTree.getType(fieldIndex);\n\n                // const type = changeTree.getType(fieldIndex);\n                const value = changeTree.getValue(fieldIndex);\n\n                // Enqueue ChangeTree to be visited\n                if (\n                    value &&\n                    value['$changes'] &&\n                    !refIdsVisited.has(value['$changes'])\n                ) {\n                    changeTrees.push(value['$changes']);\n                    value['$changes'].ensureRefId();\n                    numChangeTrees++;\n                }\n\n                if (operation.op === OPERATION.TOUCH) {\n                    continue;\n                }\n\n                if (Schema.is(type)) {\n                    assertInstanceType(value, type as typeof Schema, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n\n                    // Try to encode inherited TYPE_ID if it's an ADD operation.\n                    if ((operation.op & OPERATION.ADD) === OPERATION.ADD) {\n                        this.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema);\n                    }\n\n                } else if (typeof(type) === \"string\") {\n                    //\n                    // Primitive values\n                    //\n                    encodePrimitiveType(type as PrimitiveType, bytes, value, ref as Schema, field);\n\n                } else {\n                    //\n                    // Custom type (MapSchema, ArraySchema, etc)\n                    //\n                    const definition = getType(Object.keys(type)[0]);\n\n                    //\n                    // ensure a ArraySchema has been provided\n                    //\n                    assertInstanceType(ref[`_${field}`], definition.constructor, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n                }\n\n                if (useFilters) {\n                    // cache begin / end index\n                    changeTree.cache(fieldIndex as number, bytes.slice(beginIndex));\n                }\n            }\n\n            if (!encodeAll && !useFilters) {\n                changeTree.discard();\n            }\n        }\n\n        return bytes;\n    }\n\n    encodeAll (useFilters?: boolean) {\n        return this.encode(true, [], useFilters);\n    }\n\n    applyFilters(client: ClientWithSessionId, encodeAll: boolean = false) {\n        const root = this;\n        const refIdsDissallowed = new Set<number>();\n\n        const $filterState = ClientState.get(client);\n\n        const changeTrees = [this.$changes];\n        let numChangeTrees = 1;\n\n        let filteredBytes: number[] = [];\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n\n            if (refIdsDissallowed.has(changeTree.refId))  {\n                // console.log(\"REFID IS NOT ALLOWED. SKIP.\", { refId: changeTree.refId })\n                continue;\n            }\n\n            const ref = changeTree.ref as Ref;\n            const isSchema: boolean = ref instanceof Schema;\n\n            encode.uint8(filteredBytes, SWITCH_TO_STRUCTURE);\n            encode.number(filteredBytes, changeTree.refId);\n\n            const clientHasRefId = $filterState.refIds.has(changeTree);\n            const isEncodeAll = (encodeAll || !clientHasRefId);\n\n            // console.log(\"REF:\", ref.constructor.name);\n            // console.log(\"Encode all?\", isEncodeAll);\n\n            //\n            // include `changeTree` on list of known refIds by this client.\n            //\n            $filterState.addRefId(changeTree);\n\n            const containerIndexes = $filterState.containerIndexes.get(changeTree)\n            const changes = (isEncodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            //\n            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n            // - see \"DELETE a field of Schema\" test case.\n            //\n            if (\n                !encodeAll &&\n                isSchema &&\n                (ref as Schema)._definition.indexesWithFilters\n            ) {\n                const indexesWithFilters = (ref as Schema)._definition.indexesWithFilters;\n                indexesWithFilters.forEach(indexWithFilter => {\n                    if (\n                        !containerIndexes.has(indexWithFilter) &&\n                        changeTree.allChanges.has(indexWithFilter)\n                    ) {\n                        if (isEncodeAll) {\n                            changes.push(indexWithFilter as any);\n\n                        } else {\n                            changes.push({ op: OPERATION.ADD, index: indexWithFilter, } as any);\n                        }\n                    }\n                });\n            }\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const change: ChangeOperation = (isEncodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                // custom operations\n                if (change.op === OPERATION.CLEAR) {\n                    encode.uint8(filteredBytes, change.op);\n                    continue;\n                }\n\n                const fieldIndex = change.index;\n\n                //\n                // Deleting fields: encode the operation + field index\n                //\n                if (change.op === OPERATION.DELETE) {\n                    //\n                    // DELETE operations also need to go through filtering.\n                    //\n                    // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                    // (check against `$filterState.refIds`)\n                    //\n\n                    if (isSchema) {\n                        encode.uint8(filteredBytes, change.op | fieldIndex);\n\n                    } else {\n                        encode.uint8(filteredBytes, change.op);\n                        encode.number(filteredBytes, fieldIndex);\n\n                    }\n                    continue;\n                }\n\n                // indexed operation\n                const value = changeTree.getValue(fieldIndex);\n                const type = changeTree.getType(fieldIndex);\n\n                if (isSchema) {\n                    // Is a Schema!\n                    const filter = (\n                        (ref as Schema)._definition.filters &&\n                        (ref as Schema)._definition.filters[fieldIndex]\n                    );\n\n                    if (filter && !filter.call(ref, client, value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);;\n                        }\n                        continue;\n                    }\n\n                } else {\n                    // Is a collection! (map, array, etc.)\n                    const parent = changeTree.parent as Ref;\n                    const filter = changeTree.getChildrenFilter();\n\n                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);\n                        }\n                        continue;\n                    }\n                }\n\n                // visit child ChangeTree on further iteration.\n                if (value['$changes']) {\n                    changeTrees.push(value['$changes']);\n                    numChangeTrees++;\n                }\n\n                //\n                // Copy cached bytes\n                //\n                if (change.op !== OPERATION.TOUCH) {\n\n                    //\n                    // TODO: refactor me!\n                    //\n\n                    if (change.op === OPERATION.ADD || isSchema) {\n                        //\n                        // use cached bytes directly if is from Schema type.\n                        //\n                        filteredBytes.push.apply(filteredBytes, changeTree.caches[fieldIndex] ?? []);\n                        containerIndexes.add(fieldIndex);\n\n                    } else {\n                        if (containerIndexes.has(fieldIndex)) {\n                            //\n                            // use cached bytes if already has the field\n                            //\n                            filteredBytes.push.apply(filteredBytes, changeTree.caches[fieldIndex] ?? []);\n\n                        } else {\n                            //\n                            // force ADD operation if field is not known by this client.\n                            //\n                            containerIndexes.add(fieldIndex);\n\n                            encode.uint8(filteredBytes, OPERATION.ADD);\n                            encode.number(filteredBytes, fieldIndex);\n\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                encode.string(filteredBytes, dynamicIndex);\n                            }\n\n                            if (value['$changes']) {\n                                encode.number(filteredBytes, value['$changes'].refId);\n\n                            } else {\n                                // \"encodePrimitiveType\" without type checking.\n                                // the type checking has been done on the first .encode() call.\n                                encode[type as string](filteredBytes, value);\n                            }\n                        }\n                    }\n\n                } else if (value['$changes'] && !isSchema) {\n                    //\n                    // TODO:\n                    // - track ADD/REPLACE/DELETE instances on `$filterState`\n                    // - do NOT always encode dynamicIndex for MapSchema.\n                    //   (If client already has that key, only the first index is necessary.)\n                    //\n\n                    encode.uint8(filteredBytes, OPERATION.ADD);\n                    encode.number(filteredBytes, fieldIndex);\n\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(filteredBytes, dynamicIndex);\n                    }\n\n                    encode.number(filteredBytes, value['$changes'].refId);\n                }\n\n            };\n        }\n\n        return filteredBytes;\n    }\n\n    clone (): this {\n        const cloned = new ((this as any).constructor);\n        const schema = this._definition.schema;\n        for (let field in schema) {\n            if (\n                typeof (this[field]) === \"object\" &&\n                typeof (this[field].clone) === \"function\"\n            ) {\n                // deep clone\n                cloned[field] = this[field].clone();\n\n            } else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n        return cloned;\n    }\n\n    triggerAll() {\n        // skip if haven't received any remote refs yet.\n        if (this.$changes.root.refs.size === 0) { return; }\n\n        const allChanges = new Map<number, DataChange[]>();\n        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);\n\n        try {\n            Schema.prototype._triggerChanges.call(this, allChanges);\n\n        } catch (e) {\n            Schema.onError(e);\n        }\n    }\n\n    toJSON () {\n        const schema = this._definition.schema;\n        const deprecated = this._definition.deprecated;\n\n        const obj = {}\n        for (let field in schema) {\n            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                    ? this[field]['toJSON']()\n                    : this[`_${field}`];\n            }\n        }\n        return obj;\n    }\n\n    discardAllChanges() {\n        this.$changes.discardAll();\n    }\n\n    protected getByIndex(index: number) {\n        return this[this._definition.fieldsByIndex[index]];\n    }\n\n    protected deleteByIndex(index: number) {\n        this[this._definition.fieldsByIndex[index]] = undefined;\n    }\n\n    private tryEncodeTypeId (bytes: number[], type: typeof Schema, targetType: typeof Schema) {\n        if (type._typeid !== targetType._typeid) {\n            encode.uint8(bytes, TYPE_ID);\n            encode.number(bytes, targetType._typeid);\n        }\n    }\n\n    private getSchemaType(bytes: number[], it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            type = (this.constructor as typeof Schema)._context.get(decode.number(bytes, it));\n        }\n\n        return type || defaultType;\n    }\n\n    private createTypeInstance (type: typeof Schema): Schema {\n        let instance: Schema = new (type as any)();\n\n        // assign root on $changes\n        instance.$changes.root = this.$changes.root;\n\n        return instance;\n    }\n\n    private _triggerAllFillChanges(ref: Ref, allChanges: Map<number, DataChange[]>) {\n        if (allChanges.has(ref['$changes'].refId)) { return; }\n\n        const changes: DataChange[] = [];\n        allChanges.set(ref['$changes'].refId || 0, changes);\n\n        if (ref instanceof Schema) {\n            const schema = ref._definition.schema;\n\n            for (let fieldName in schema) {\n                const _field = `_${fieldName}`;\n                const value = ref[_field];\n\n                if (value !== undefined) {\n                    changes.push({\n                        op: OPERATION.ADD,\n                        field: fieldName,\n                        value,\n                        previousValue: undefined\n                    });\n\n                    if (value['$changes'] !== undefined) {\n                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                    }\n\n                }\n            }\n\n        } else {\n            const entries: IterableIterator<[any, any]>  = ref.entries();\n            let iter: IteratorResult<[any, any]>;\n\n            while ((iter = entries.next()) && !iter.done) {\n                const [key, value] = iter.value;\n\n                changes.push({\n                    op: OPERATION.ADD,\n                    field: key,\n                    dynamicIndex: key,\n                    value: value,\n                    previousValue: undefined,\n                });\n\n                if (value['$changes'] !== undefined) {\n                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                }\n            }\n        }\n    }\n\n    private _triggerChanges(allChanges: Map<number, DataChange[]>) {\n        allChanges.forEach((changes, refId) => {\n            if (changes.length > 0) {\n                const ref = this.$changes.root.refs.get(refId);\n                const isSchema = ref instanceof Schema;\n\n                for (let i = 0; i < changes.length; i++) {\n                    const change = changes[i];\n                    const listener = ref['$listeners'] && ref['$listeners'][change.field];\n\n                    if (!isSchema) {\n                        if (change.op === OPERATION.ADD && change.previousValue === undefined) {\n                            (ref as SchemaDecoderCallbacks).onAdd?.(change.value, change.dynamicIndex ?? change.field);\n\n                        } else if (change.op === OPERATION.DELETE) {\n                            //\n                            // FIXME: `previousValue` should always be avaiiable.\n                            // ADD + DELETE operations are still encoding DELETE operation.\n                            //\n                            if (change.previousValue !== undefined) {\n                                (ref as SchemaDecoderCallbacks).onRemove?.(change.previousValue, change.dynamicIndex ?? change.field);\n                            }\n\n                        } else if (change.op === OPERATION.DELETE_AND_ADD) {\n                            if (change.previousValue !== undefined) {\n                                (ref as SchemaDecoderCallbacks).onRemove?.(change.previousValue, change.dynamicIndex);\n                            }\n                            (ref as SchemaDecoderCallbacks).onAdd?.(change.value, change.dynamicIndex);\n\n                        } else if (\n                            change.op === OPERATION.REPLACE ||\n                            change.value !== change.previousValue\n                        ) {\n                            (ref as SchemaDecoderCallbacks).onChange?.(change.value, change.dynamicIndex);\n                        }\n                    }\n\n                    //\n                    // trigger onRemove on child structure.\n                    //\n                    if (\n                        (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                        change.previousValue instanceof Schema &&\n                        change.previousValue.onRemove\n                    ) {\n                        change.previousValue.onRemove();\n                    }\n\n                    if (listener) {\n                        try {\n                            listener.invoke(change.value, change.previousValue);\n                        } catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n\n                if (isSchema) {\n                    if (ref.onChange) {\n                        try {\n                            (ref as Schema).onChange(changes);\n                        } catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n\n            }\n\n        });\n    }\n}\n"]}