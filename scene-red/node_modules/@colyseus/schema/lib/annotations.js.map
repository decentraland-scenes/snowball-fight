{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeTree } from './changes/ChangeTree';\nimport { Schema } from './Schema';\nimport { ArraySchema, getArrayProxy } from './types/ArraySchema';\nimport { MapSchema, getMapProxy } from './types/MapSchema';\nimport { getType } from './types';\n\n/**\n * Data types\n */\nexport type PrimitiveType =\n    \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    typeof Schema;\n\nexport type DefinitionType = PrimitiveType\n    | PrimitiveType[]\n    | { array: PrimitiveType }\n    | { map: PrimitiveType }\n    | { collection: PrimitiveType }\n    | { set: PrimitiveType };\n\nexport type Definition = { [field: string]: DefinitionType };\nexport type FilterCallback<\n    T extends Schema = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: ClientWithSessionId, value: V) => boolean) |\n    ((this: T, client: ClientWithSessionId, value: V, root: R) => boolean)\n);\n\nexport type FilterChildrenCallback<\n    T extends Schema = any,\n    K = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: ClientWithSessionId, key: K, value: V) => boolean) |\n    ((this: T, client: ClientWithSessionId, key: K, value: V, root: R) => boolean)\n)\n\nexport class SchemaDefinition {\n    schema: Definition;\n\n    //\n    // TODO: use a \"field\" structure combining all these properties per-field.\n    //\n\n    indexes: { [field: string]: number } = {};\n    fieldsByIndex: { [index: number]: string } = {};\n\n    filters: { [field: string]: FilterCallback };\n    indexesWithFilters: number[];\n    childFilters: { [field: string]: FilterChildrenCallback }; // childFilters are used on Map, Array, Set items.\n\n    deprecated: { [field: string]: boolean } = {};\n    descriptors: PropertyDescriptorMap & ThisType<any> = {};\n\n    static create(parent?: SchemaDefinition) {\n        const definition = new SchemaDefinition();\n\n        // support inheritance\n        definition.schema = Object.assign({}, parent && parent.schema || {});\n        definition.indexes = Object.assign({}, parent && parent.indexes || {});\n        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n\n        return definition;\n    }\n\n    addField(field: string, type: DefinitionType) {\n        const index = this.getNextFieldIndex();\n        this.fieldsByIndex[index] = field;\n        this.indexes[field] = index;\n        this.schema[field] = (Array.isArray(type))\n            ? { array: type[0] }\n            : type;\n    }\n\n    addFilter(field: string, cb: FilterCallback) {\n        if (!this.filters) {\n            this.filters = {};\n            this.indexesWithFilters = [];\n        }\n        this.filters[this.indexes[field]] = cb;\n        this.indexesWithFilters.push(this.indexes[field]);\n        return true;\n    }\n\n    addChildrenFilter(field: string, cb: FilterChildrenCallback) {\n        const index = this.indexes[field];\n        const type = this.schema[field];\n\n        if (getType(Object.keys(type)[0])) {\n            if (!this.childFilters) { this.childFilters = {}; }\n\n            this.childFilters[index] = cb;\n            return true;\n\n        } else {\n            console.warn(`@filterChildren: field '${field}' can't have children. Ignoring filter.`);\n        }\n    }\n\n    getChildrenFilter(field: string) {\n        return this.childFilters && this.childFilters[this.indexes[field]];\n    }\n\n    getNextFieldIndex() {\n        return Object.keys(this.schema || {}).length;\n    }\n}\n\nexport function hasFilter(klass: typeof Schema) {\n    return klass._context && klass._context.useFilters;\n}\n\n// Colyseus integration\nexport type ClientWithSessionId = { sessionId: string } & any;\n\nexport class Context {\n    types: {[id: number]: typeof Schema} = {};\n    schemas = new Map<typeof Schema, number>();\n    useFilters = false;\n\n    has(schema: typeof Schema) {\n        return this.schemas.has(schema);\n    }\n\n    get(typeid: number) {\n        return this.types[typeid];\n    }\n\n    add(schema: typeof Schema, typeid: number = this.schemas.size) {\n        // FIXME: move this to somewhere else?\n        // support inheritance\n        schema._definition = SchemaDefinition.create(schema._definition);\n\n        schema._typeid = typeid;\n        this.types[typeid] = schema;\n        this.schemas.set(schema, typeid);\n    }\n\n    static create(context: Context = new Context) {\n        return function (definition: DefinitionType) {\n            return type(definition, context);\n        }\n    }\n}\n\nexport const globalContext = new Context();\n\n/**\n * `@type()` decorator for proxies\n */\nexport function type (type: DefinitionType, context: Context = globalContext): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        if (!type) {\n            throw new Error(\"Type not found. Ensure your `@type` annotations are correct and that you don't have any circular dependencies.\");\n        }\n\n        const constructor = target.constructor as typeof Schema;\n        constructor._context = context;\n\n        /*\n         * static schema\n         */\n        if (!context.has(constructor)) {\n            context.add(constructor);\n        }\n\n        const definition = constructor._definition;\n        definition.addField(field, type);\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (definition.descriptors[field]) {\n            if (definition.deprecated[field]) {\n                // do not create accessors for deprecated properties.\n                return;\n\n            } else {\n                // trying to define same property multiple times across inheritance.\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                try {\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n\n                } catch (e) {\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                    throw new Error(`${e.message} ${definitionAtLine}`);\n                }\n            }\n        }\n\n        const isArray = ArraySchema.is(type);\n        const isMap = !isArray && MapSchema.is(type);\n\n        // TODO: refactor me.\n        // Allow abstract intermediary classes with no fields to be serialized\n        // (See \"should support an inheritance with a Schema type without fields\" test)\n        if (typeof (type) !== \"string\" && !Schema.is(type)) {\n            const childType = Object.values(type)[0];\n            if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                context.add(childType);\n            }\n        }\n\n        const fieldCached = `_${field}`;\n\n        definition.descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n\n        definition.descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n\n            set: function (this: Schema, value: any) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n\n                if (\n                    value !== undefined &&\n                    value !== null\n                ) {\n                    // automaticallty transform Array into ArraySchema\n                    if (isArray && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (isMap && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    // try to turn provided structure into a Proxy\n                    if (value['$proxy'] === undefined) {\n                        if (isMap) {\n                            value = getMapProxy(value);\n\n                        } else if (isArray) {\n                            value = getArrayProxy(value);\n                        }\n                    }\n\n                    // flag the change for encoding.\n                    this.$changes.change(field);\n\n                    //\n                    // call setParent() recursively for this and its child\n                    // structures.\n                    //\n                    if (value['$changes']) {\n                        (value['$changes'] as ChangeTree).setParent(\n                            this,\n                            this.$changes.root,\n                            this._definition.indexes[field],\n                        );\n                    }\n\n                } else {\n                    //\n                    // Setting a field to `null` or `undefined` will delete it.\n                    //\n                    this.$changes.delete(field);\n                }\n\n                this[fieldCached] = value;\n            },\n\n            enumerable: true,\n            configurable: true\n        };\n    }\n}\n\n/**\n * `@filter()` decorator for defining data filters per client\n */\n\nexport function filter<T extends Schema, V, R extends Schema>(cb: FilterCallback<T, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        if (definition.addFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\nexport function filterChildren<T extends Schema, K, V, R extends Schema>(cb: FilterChildrenCallback<T, K, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n        if (definition.addChildrenFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true, context: Context = globalContext): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        definition.deprecated[field] = true;\n\n        if (throws) {\n            definition.descriptors[field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: { [property: string]: DefinitionType },\n    context: Context = target._context || globalContext\n) {\n    for (let field in fields) {\n        type(fields[field], context)(target.prototype, field);\n    }\n    return target;\n}\n"]}