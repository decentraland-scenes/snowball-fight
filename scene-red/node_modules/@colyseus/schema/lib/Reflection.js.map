{"version":3,"file":"Reflection.js","sourceRoot":"","sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourcesContent":["import { type, PrimitiveType, Context, DefinitionType } from \"./annotations\";\nimport { Schema } from \"./Schema\";\nimport { ArraySchema } from \"./types/ArraySchema\";\nimport { getType } from \"./types\";\nimport { Iterator } from \"./encoding/decode\";\n\nconst reflectionContext = new Context();\n\n/**\n * Reflection\n */\nexport class ReflectionField extends Schema {\n    @type(\"string\", reflectionContext)\n    name: string;\n\n    @type(\"string\", reflectionContext)\n    type: string;\n\n    @type(\"number\", reflectionContext)\n    referencedType: number;\n}\n\nexport class ReflectionType extends Schema {\n    @type(\"number\", reflectionContext)\n    id: number;\n\n    @type([ ReflectionField ], reflectionContext)\n    fields: ArraySchema<ReflectionField> = new ArraySchema<ReflectionField>();\n}\n\nexport class Reflection extends Schema {\n    @type([ ReflectionType ], reflectionContext)\n    types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\n\n    @type(\"number\", reflectionContext)\n    rootType: number;\n\n    static encode (instance: Schema) {\n        const rootSchemaType = instance.constructor as typeof Schema;\n\n        const reflection = new Reflection();\n        reflection.rootType = rootSchemaType._typeid;\n\n        const buildType = (currentType: ReflectionType, schema: any) => {\n            for (let fieldName in schema) {\n                const field = new ReflectionField();\n                field.name = fieldName;\n\n                let fieldType: string;\n\n                if (typeof (schema[fieldName]) === \"string\") {\n                    fieldType = schema[fieldName];\n\n                } else {\n                    const type = schema[fieldName];\n                    let childTypeSchema: typeof Schema;\n\n                    //\n                    // TODO: refactor below.\n                    //\n                    if (Schema.is(type)) {\n                        fieldType = \"ref\";\n                        childTypeSchema = schema[fieldName];\n\n                    } else {\n                        fieldType = Object.keys(type)[0];\n\n                        if (typeof(type[fieldType]) === \"string\") {\n                            fieldType += \":\" + type[fieldType]; // array:string\n\n                        } else {\n                            childTypeSchema = type[fieldType];\n                        }\n                    }\n\n                    field.referencedType = (childTypeSchema)\n                        ? childTypeSchema._typeid\n                        : -1;\n                }\n\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n\n            reflection.types.push(currentType);\n        }\n\n        const types = rootSchemaType._context.types;\n        for (let typeid in types) {\n            const type = new ReflectionType();\n            type.id = Number(typeid);\n            buildType(type, types[typeid]._definition.schema);\n        }\n\n        return reflection.encodeAll();\n    }\n\n    static decode<T extends Schema = Schema>(bytes: number[], it?: Iterator): T {\n        const context = new Context();\n\n        const reflection = new Reflection();\n        reflection.decode(bytes, it);\n\n        const schemaTypes = reflection.types.reduce((types, reflectionType) => {\n            const schema: typeof Schema = class _ extends Schema {};\n            const typeid = reflectionType.id;\n            types[typeid] = schema\n            context.add(schema, typeid);\n            return types;\n        }, {});\n\n        reflection.types.forEach((reflectionType) => {\n            const schemaType = schemaTypes[reflectionType.id];\n\n            reflectionType.fields.forEach(field => {\n                if (field.referencedType !== undefined) {\n                    let fieldType = field.type;\n                    let refType = schemaTypes[field.referencedType];\n\n                    // map or array of primitive type (-1)\n                    if (!refType) {\n                        const typeInfo = field.type.split(\":\");\n                        fieldType = typeInfo[0];\n                        refType = typeInfo[1];\n                    }\n\n                    if (fieldType === \"ref\") {\n                        type(refType, context)(schemaType.prototype, field.name);\n\n                    } else {\n                        type({ [fieldType]: refType } as DefinitionType, context)(schemaType.prototype, field.name);\n                    }\n\n                } else {\n                    type(field.type as PrimitiveType, context)(schemaType.prototype, field.name);\n                }\n            });\n        })\n\n        const rootType: any = schemaTypes[reflection.rootType];\n        const rootInstance = new rootType();\n\n        /**\n         * auto-initialize referenced types on root type\n         * to allow registering listeners immediatelly on client-side\n         */\n        for (let fieldName in rootType._definition.schema) {\n            const fieldType = rootType._definition.schema[fieldName];\n\n            if (typeof(fieldType) !== \"string\") {\n                rootInstance[fieldName] = (typeof (fieldType) === \"function\")\n                    ? new (fieldType as any)() // is a schema reference\n                    : new (getType(Object.keys(fieldType)[0])).constructor(); // is a \"collection\"\n            }\n        }\n\n        return rootInstance;\n    }\n}"]}